//#define DEBUG_OUTPUT
//#define DEBUG_CELLX 10
//#define DEBUG_CELLY 10

/*
 *  Calculate everything without using LDS caching
 */
__kernel REQD_WG_SIZE_FULL_TS
void promaidesScheme ( 
			__constant	cl_double *  				dTimestep,					// Timestep
			__global	cl_double const * restrict	dBedElevation,				// Bed elevation
			__global	cl_double *  				pCellStateSrc,					// Current cell state data
			__global	cl_double *  				pCellStateDst,					// Current cell state data
			__global	cl_double const * restrict	dManning,					// Manning values
			__global	FlowStates const * restrict	flowstates					// Flow States data
		)
{

	// Identify the cell we're reconstructing (no overlap)
	__private cl_long					lIdxX			= get_global_id(0);
	__private cl_long					lIdxY			= get_global_id(1);
	__private cl_ulong					ulIdx, ulIdxNeigN, ulIdxNeigE, ulIdxNeigS, ulIdxNeigW;
	__private cl_uchar					ucDirection;
	
	ulIdx = getCellID(lIdxX, lIdxY);
	
	// Don't bother if we've gone beyond the domain bounds
	if ( lIdxX > DOMAIN_COLS - 1 || lIdxY > DOMAIN_ROWS - 1 ||  lIdxX < 0 || lIdxY < 0 ){
		return;
	}

	__private cl_double		dLclTimestep	= *dTimestep;
	__private cl_double		dManningCoef;
	__private cl_double		dCellBedElev,dNeigBedElevN,dNeigBedElevE,dNeigBedElevS,dNeigBedElevW;
	__private cl_double		opt_h,opt_hN,opt_hE,opt_hS,opt_hW;
	__private cl_double		opt_cN, opt_cE, opt_cS, opt_cW;
	__private cl_double		opt_z, opt_zNmax, opt_zEmax, opt_zSmax, opt_zWmax;
	__private cl_double		opt_s, opt_sN, opt_sE,opt_sS,opt_sW;
	__private cl_double		pCellData,pNeigDataN,pNeigDataE,pNeigDataS,pNeigDataW;
	
	__private cl_double		ds_dt_data			=	0.0;
	__private FlowStates	flowStateCell;

	// Also don't bother if we've gone beyond the total simulation time
	if (dLclTimestep <= 0.0)
	{
		//printf("90, ulIdx: %f dLclTimestep: %f \n",ulIdx*1.0, dLclTimestep);
		// TODO: Is there a way of avoiding this?!
		pCellStateDst[ulIdx] = pCellStateSrc[ulIdx];
		return;
	}

	// Load cell data
	dCellBedElev		= dBedElevation[ ulIdx ];
	pCellData			= pCellStateSrc[ ulIdx ];
	dManningCoef		= dManning[ ulIdx ];
	flowStateCell		= flowstates[ ulIdx ];

	// Cell disabled?
	if ( pCellData == -9999.0 || !flowStateCell.isFlowElement)
	{
		//printf("104/n");
		pCellStateDst[ ulIdx ] = pCellData;
		return;
	}

	
	//We are reading outside of boundary when we are on the edge but wouldn't this be faster?
	ulIdxNeigN = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_N);
	dNeigBedElevN	= dBedElevation [ ulIdxNeigN ];
	pNeigDataN		= pCellStateSrc	[ ulIdxNeigN ];

	ulIdxNeigE = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_E);
	dNeigBedElevE	= dBedElevation [ ulIdxNeigE ];
	pNeigDataE		= pCellStateSrc	[ ulIdxNeigE ];

	ulIdxNeigS = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_S);
	dNeigBedElevS	= dBedElevation [ ulIdxNeigS ];
	pNeigDataS		= pCellStateSrc	[ ulIdxNeigS ];

	ulIdxNeigW = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_W);
	dNeigBedElevW	= dBedElevation [ ulIdxNeigW ];
	pNeigDataW		= pCellStateSrc	[ ulIdxNeigW ];

	

	bool isFlowElement	= flowStateCell.isFlowElement;
	bool noflow_x		= flowStateCell.noflow_x;
	bool noflow_y		= flowStateCell.noflow_y;
	bool noflow_nx		= flowStateCell.noflow_nx;
	bool noflow_ny		= flowStateCell.noflow_ny;
	bool opt_pol_x		= flowStateCell.opt_pol_x;
	bool opt_pol_y		= flowStateCell.opt_pol_y;
	bool opt_pol_nx		= false;
	bool opt_pol_ny		= false;

	//if (ulIdx==3274){printf("pCellData %f N: %f E: %f S: %f W: %f\n",pCellData, pNeigDataN-dNeigBedElevN, pNeigDataE-dNeigBedElevE,pNeigDataS-dNeigBedElevS, pNeigDataW-dNeigBedElevW);}
	
	//set data
	opt_z = dCellBedElev;
	if((pCellData  - opt_z) < VERY_SMALL){
		opt_h = 0.0;
		opt_s = opt_z;
	}else{
		opt_h = pCellData  - opt_z;
		opt_s = pCellData;
	}


	if(opt_pol_x || opt_pol_y){
		printf("We shouldn't be here xxxxxxxxxxxxxxxxx \n");
	//	return;
	}




	if(!noflow_x){
		opt_hE = pNeigDataE - dNeigBedElevE;
		opt_sE = pNeigDataE;
		opt_zEmax = opt_z > dNeigBedElevE ? opt_z : dNeigBedElevE;
		opt_cE = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigE])/pow(DOMAIN_DELTAX,1.5);
		
		//if (ulIdx==3274){printf("Initial ds_dt_data %f\n",ds_dt_data);}
		if(!opt_pol_x){
			ds_dt_data += manning_Solver(opt_h, opt_hE, opt_s,opt_sE,opt_zEmax,opt_cE, false);
			//if (ulIdx==3274){printf("ds_dt_data E %f\n",ds_dt_data);}
		}else{
			ds_dt_data += polini_Solver(opt_h, opt_hE, opt_s,opt_sE,opt_zEmax,opt_cE, false);
		}
	}
	
	
	if(!noflow_nx){

		opt_hW = pNeigDataW - dNeigBedElevW;
		opt_sW = pNeigDataW;
		opt_zWmax = opt_z > dNeigBedElevW ? opt_z : dNeigBedElevW;
		opt_cW = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigW])/pow(DOMAIN_DELTAX,1.5);

		if(!opt_pol_nx){
			ds_dt_data += manning_Solver(opt_h, opt_hW, opt_s,opt_sW,opt_zWmax,opt_cW, false);
		}else{
			ds_dt_data += polini_Solver(opt_h, opt_hW, opt_s,opt_sW,opt_zWmax,opt_cW, false);
		}
	}

	
	//in y-direction
	if(!noflow_y){
		opt_hN = pNeigDataN - dNeigBedElevN;
		opt_sN = pNeigDataN;
		opt_zNmax = opt_z > dNeigBedElevN ? opt_z : dNeigBedElevN;
		opt_cN = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigN])/pow(DOMAIN_DELTAX,1.5);
		if(!opt_pol_y){
			ds_dt_data += manning_Solver(opt_h, opt_hN, opt_s,opt_sN,opt_zNmax,opt_cN, false);
		}else{
			ds_dt_data += polini_Solver(opt_h, opt_hN, opt_s,opt_sN,opt_zNmax,opt_cN, false);
		}
	}

	if(!noflow_ny){
		opt_hS = pNeigDataS - dNeigBedElevS;
		opt_sS = pNeigDataS;
		opt_zSmax = opt_z > dNeigBedElevS ? opt_z : dNeigBedElevS;
		opt_cS = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigS])/pow(DOMAIN_DELTAX,1.5);
		if(!opt_pol_ny){
			ds_dt_data += manning_Solver(opt_h, opt_hS, opt_s,opt_sS,opt_zSmax,opt_cS, false);
		}else{
			ds_dt_data += polini_Solver(opt_h, opt_hS, opt_s,opt_sS,opt_zSmax,opt_cS, false);
		}
	}
	
	//if (ulIdx==3274){printf("Final ds_dt_data%f\n\n",ds_dt_data);}
	
	// Update the flow state
	pCellData = pCellData	+ dLclTimestep * ds_dt_data;
	
	pCellStateDst[ulIdx] = pCellData;

}


cl_double manning_Solver(
	cl_double opt_h, 
	cl_double opt_h_Neig, 
	cl_double opt_s,
	cl_double opt_s_Neig,
	cl_double opt_zmax_Neig,
	cl_double opt_c_Neig,
	bool debug)
	{

		cl_double flow_depth = 0;
		cl_double flow_depth_Neig;
		cl_double ds_dt_buff;
		cl_double delta_h;
		cl_double abs_delta_h;
		if (debug){printf("g0\n"); }

		if(opt_h > VERY_SMALL || opt_h_Neig > VERY_SMALL){
			if (debug){printf("g1\n"); }

			flow_depth = opt_s - opt_zmax_Neig;
			if (debug){printf("flow_depth %f opt_s %f opt_zmax_Neig %f\n",flow_depth,opt_s,opt_zmax_Neig); }

			flow_depth_Neig = fmax(0, opt_s_Neig - opt_zmax_Neig);
			if (debug){printf("flow_depth_Neig %f\n",flow_depth_Neig); }

			flow_depth = fmax( flow_depth , flow_depth_Neig);
			if (debug){printf("flow_depth %f\n",flow_depth); }


			if(flow_depth > VERY_SMALL){
				if (debug){printf("g2\n"); }
				//diffusive wave
				delta_h = opt_s_Neig - opt_s;
				abs_delta_h=fabs(delta_h);

				if(abs_delta_h > VERY_SMALL){

					if(abs_delta_h<=0.005078){
						return opt_c_Neig * pow(flow_depth, (5.0/3.0))*0.10449968880528*atan(159.877741951379*delta_h); //0.0152
					}
					else{
						return opt_c_Neig * pow(flow_depth, (5.0/3.0)) *(delta_h/pow(abs_delta_h,0.5));
					}

					//set the result
					return 0;
				}
			}
		}

		return 0;
	}

cl_double polini_Solver(
	cl_double opt_h, 
	cl_double opt_h_Neig, 
	cl_double opt_s,
	cl_double opt_s_Neig,
	cl_double opt_zmax_Neig,
	cl_double opt_c_Neig,
	bool debug)
	{
		printf("polini error llllllllllllllllllllllllllllllll\n");

		

		cl_double flow_depth		=  opt_s - opt_zmax_Neig;
		cl_double flow_depth_neigh	=  opt_s_Neig- opt_zmax_Neig;
		cl_double reduction_term;

		//noFlow
		if((flow_depth<=0.0 && flow_depth_neigh<=0.0) ||	(fabs(flow_depth-flow_depth_neigh)<=0.0)){
			return 0.0;
		}else{
			//flow out of this element without submerged weirflow reduction into the neihgbouring element
			if( flow_depth > 0.0 && flow_depth_neigh <= 0.0){
				return -1.0 * Cfacweir * opt_c_Neig * pow(flow_depth, (3.0/2.0));
			}
			//flow out of the neighbouring element without submerged weirflow reduction into this element
			else if(flow_depth<= 0.0 && flow_depth_neigh > 0.0){

				return Cfacweir * opt_c_Neig * pow(flow_depth_neigh,(3.0/2.0));
			}
			//submerged weirflow with reduction
			else if(flow_depth > 0.0 && flow_depth_neigh > 0.0){
				//flow into the neihgbouring element
				if(flow_depth>flow_depth_neigh){
					//reduction of the discharge (submerged weirflow)
					reduction_term = (1.0-flow_depth_neigh/flow_depth);
					//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
					if(reduction_term <= 0.000463529){
						return -1.0 * Cfacweir * opt_c_Neig * pow(flow_depth,(3.0/2.0)) * 0.057965266895 * atan(8984.365582471040 * reduction_term);
					}
					else{
						return -1.0 * Cfacweir * opt_c_Neig * pow(flow_depth,(3.0/2.0)) * pow(reduction_term,(1.0/3.0));
					}

				}
				//flow into this element
				else{
					//reduction of the discharge (submerged weirflow)
					reduction_term = (1.0 - flow_depth/flow_depth_neigh);
					//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
					if(reduction_term <= 0.000463529){
						return Cfacweir * opt_c_Neig * pow(flow_depth_neigh,(3.0/2.0)) * 0.057965266895 * atan(8984.365582471040 * reduction_term);
					}
					else{
						return Cfacweir * opt_c_Neig * pow(flow_depth_neigh,(3.0/2.0)) * pow(reduction_term,(1.0/3.0));
					}

				}
			}
			return 0.0;
		}
		return 0;
	}