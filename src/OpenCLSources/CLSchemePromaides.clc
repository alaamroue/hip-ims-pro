//#define DEBUG_OUTPUT
//#define DEBUG_CELLX 10
//#define DEBUG_CELLY 10

/*
 *  Calculate everything without using LDS caching
 */
__kernel REQD_WG_SIZE_FULL_TS
void promaidesScheme ( 
			__constant	cl_double *  				dTimestep,					// Timestep
			__global	cl_double const * restrict	dBedElevation,				// Bed elevation
			__global	cl_double *  				pCellStateSrc,					// Current cell state data
			__global	cl_double *  				pCellStateDst,					// Current cell state data
			__global	cl_double const * restrict	dManning,					// Manning values
			__global	FlowStates const * restrict	flowstates					// Flow States data
		)
{

	// Identify the cell we're reconstructing (no overlap)
	__private cl_long					lIdxX			= get_global_id(0);
	__private cl_long					lIdxY			= get_global_id(1);
	__private cl_ulong					ulIdx, ulIdxNeigN, ulIdxNeigE, ulIdxNeigS, ulIdxNeigW;
	__private cl_uchar					ucDirection;
	
	ulIdx = getCellID(lIdxX, lIdxY);
	
	// Don't bother if we've gone beyond the domain bounds
	if ( lIdxX > DOMAIN_COLS - 1 || lIdxY > DOMAIN_ROWS - 1 ||  lIdxX < 0 || lIdxY < 0 ){
		return;
	}


	__private cl_double		dLclTimestep	= *dTimestep;
	__private cl_double		dManningCoef;
	__private cl_double		dCellBedElev,dNeigBedElevN,dNeigBedElevE,dNeigBedElevS,dNeigBedElevW;
	__private cl_double		opt_h,opt_hN,opt_hE,opt_hS,opt_hW;
	__private cl_double		opt_cN, opt_cE, opt_cS, opt_cW;
	__private cl_double		opt_z, opt_zNmax, opt_zEmax, opt_zSmax, opt_zWmax;
	__private cl_double		opt_s, opt_sN, opt_sE,opt_sS,opt_sW;
	__private cl_double		pCellData,pNeigDataN,pNeigDataE,pNeigDataS,pNeigDataW;
	

	__private cl_uchar		ucStop				=	0;
	__private cl_uchar		ucDryCount			=	0;
	__private cl_double		ds_dt_data			=	0.0;
	__private cl_double		flow_depth			=	0.0;
	__private cl_double		flow_depth_neigh	=	0.0;
	__private cl_double		delta_h				=	0.0;
	__private cl_double		abs_delta_h			=	0.0;
	__private cl_double		ds_dt_buff			=	0.0;
	__private cl_double		reduction_term		=	0.0;
	__private FlowStates	flowStateCell, flowStateCellS, flowStateCellW;

	//This would be passed as a variable

	//if (lIdxX==DOMAIN_COLS-1) {
	//	noflow_x = true;
	//}
	//if (lIdxY==DOMAIN_ROWS-1){
	//	noflow_y = true;
	//}

	// Also don't bother if we've gone beyond the total simulation time
	if (dLclTimestep <= 0.0)
	{
		//printf("90, ulIdx: %f dLclTimestep: %f \n",ulIdx*1.0, dLclTimestep);
		// TODO: Is there a way of avoiding this?!
		pCellStateDst[ulIdx] = pCellStateSrc[ulIdx];
		return;
	}

	// Load cell data
	dCellBedElev		= dBedElevation[ ulIdx ];
	pCellData			= pCellStateSrc[ ulIdx ];
	dManningCoef		= dManning[ ulIdx ];
	flowStateCell		= flowstates[ ulIdx ];

	// Cell disabled?
	if ( pCellData == -9999.0 || !flowStateCell.isFlowElement)
	{
		//printf("104/n");
		pCellStateDst[ ulIdx ] = pCellData;
		return;
	}

	
	
	ulIdxNeigN = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_N);
	dNeigBedElevN	= dBedElevation [ ulIdxNeigN ];
	pNeigDataN		= pCellStateSrc	[ ulIdxNeigN ];

	ulIdxNeigE = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_E);
	dNeigBedElevE	= dBedElevation [ ulIdxNeigE ];
	pNeigDataE		= pCellStateSrc	[ ulIdxNeigE ];

	ulIdxNeigS = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_S);
	dNeigBedElevS	= dBedElevation [ ulIdxNeigS ];
	pNeigDataS		= pCellStateSrc	[ ulIdxNeigS ];
	flowStateCellS	= flowstates[ ulIdxNeigS ];

	ulIdxNeigW = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_W);
	dNeigBedElevW	= dBedElevation [ ulIdxNeigW ];
	pNeigDataW		= pCellStateSrc	[ ulIdxNeigW ];
	flowStateCellW	= flowstates[ ulIdxNeigW ];

	

	bool isFlowElement	= flowStateCell.isFlowElement;
	bool noflow_x		= flowStateCell.noflow_x;
	bool noflow_y		= flowStateCell.noflow_y;
	bool noflow_nx		= !flowStateCellW.isFlowElement;
	bool noflow_ny		= !flowStateCellS.isFlowElement;
	bool opt_pol_x		= flowStateCell.opt_pol_x;
	bool opt_pol_y		= flowStateCell.opt_pol_y;
	bool opt_pol_nx		= flowStateCellW.opt_pol_x;
	bool opt_pol_ny		= flowStateCellS.opt_pol_y;

	if(!(lIdxX==DOMAIN_ROWS-1)){
		noflow_x = true;
	}else if(!(lIdxX==0)){
		noflow_nx = true;
	}
	
	if(!(lIdxY==DOMAIN_COLS-1)){
		noflow_y = true;
	}else if(!(lIdxY==0)){
		noflow_ny = true;
	}


	if (ulIdx==3274){
		/*
		if(isFlowElement){	printf("isFlowElement	:True\n");}else{printf("isFlowElement	:False\n");}
		if(noflow_x){		printf("noflow_x		:True\n");}else{printf("noflow_x		:False\n");}
		if(noflow_y){		printf("noflow_y		:True\n");}else{printf("noflow_y		:False\n");}
		if(noflow_nx){		printf("noflow_nx		:True\n");}else{printf("noflow_nx		:False\n");}
		if(noflow_ny){		printf("noflow_ny		:True\n");}else{printf("noflow_ny		:False\n");}
		if(opt_pol_x){		printf("opt_pol_x		:True\n");}else{printf("opt_pol_x		:False\n");}
		if(opt_pol_y){		printf("opt_pol_y		:True\n");}else{printf("opt_pol_y		:False\n");}
		if(opt_pol_nx){		printf("opt_pol_nx		:True\n");}else{printf("opt_pol_nx		:False\n");}
		if(opt_pol_ny){		printf("opt_pol_ny		:True\n");}else{printf("opt_pol_ny		:False\n");}
		printf("\n\n");	
		*/

		
		//printf("pCellData %f N: %f E: %f S: %f W: %f\n",pCellData, pNeigDataN-dNeigBedElevN, pNeigDataE-dNeigBedElevE,pNeigDataS-dNeigBedElevS, pNeigDataW-dNeigBedElevW);
	}
	




	//set data
	opt_z = dCellBedElev;
	//if((pCellData  - opt_z) < VERY_SMALL){
	//	opt_h = 0.0;
	//	opt_s = opt_z;
	//}else{
		opt_h = pCellData  - opt_z;
		opt_s = pCellData;
	//}


	if(opt_pol_x || opt_pol_y){
		printf("We shouldn't be here xxxxxxxxxxxxxxxxx \n");
	//	return;
	}




	if(!noflow_x){
		opt_hE = pNeigDataE - dNeigBedElevE;
		opt_sE = pNeigDataE;
		opt_zEmax = opt_z > dNeigBedElevE ? opt_z : dNeigBedElevE;
		opt_cE = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigE])/pow(DOMAIN_DELTAX,1.5);

		if(!opt_pol_x){
			ds_dt_data += manning_Solver(opt_h, opt_hE, opt_s,opt_sE,opt_zEmax,opt_cE);

		}else{
			printf("polini errorE: lIdxX %ld lIdxX %ld\n", lIdxX, lIdxY);
			flow_depth		 =  opt_s - opt_zEmax;
			flow_depth_neigh =  opt_sE- opt_zEmax;

			//noFlow
			if((flow_depth<=0.0 && flow_depth_neigh<=0.0) ||	(fabs(flow_depth-flow_depth_neigh)<=0.0)){
				ds_dt_buff=0.0;
			}
			else{ //Flow
				//flow out of this element without submerged weirflow reduction into the neihgbouring element
				if( flow_depth > 0.0 && flow_depth_neigh <= 0.0){
					ds_dt_buff = -1.0 * Cfacweir * opt_cE * pow(flow_depth, (3.0/2.0));

				}
				//flow out of the neighbouring element without submerged weirflow reduction into this element
				else if(flow_depth<= 0.0 && flow_depth_neigh > 0.0){

					ds_dt_buff = Cfacweir * opt_cE * pow(flow_depth_neigh,(3.0/2.0));
				}
				//submerged weirflow with reduction
				else if(flow_depth > 0.0 && flow_depth_neigh > 0.0){
					//flow out of this element into the neihgbouring element
					if(flow_depth>flow_depth_neigh){
						ds_dt_buff = Cfacweir * opt_cE * pow(flow_depth,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term = (1.0-flow_depth_neigh/flow_depth);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term <= 0.000463529){
							ds_dt_buff=-1.0 * ds_dt_buff * 0.057965266895 * atan(8984.365582471040 * reduction_term);
						}
						else{
							ds_dt_buff= -1.0 * ds_dt_buff * pow(reduction_term,(1.0/3.0));
						}

					}
					//flow out of the neighbouring element into this element
					else{
						ds_dt_buff = Cfacweir * opt_cE * pow(flow_depth_neigh,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term = (1.0 - flow_depth/flow_depth_neigh);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term <= 0.000463529){
							ds_dt_buff = ds_dt_buff * 0.057965266895 * atan(8984.365582471040 * reduction_term);
						}
						else{
							ds_dt_buff = ds_dt_buff * pow(reduction_term,(1.0/3.0));
						}

					}
				}
				//set the result
				ds_dt_data = ds_dt_data + ds_dt_buff;
			}
		}
	}
	
	
	if(!noflow_nx){

		opt_hW = pNeigDataW - dNeigBedElevW;
		opt_sW = pNeigDataW;
		opt_zWmax = opt_z > dNeigBedElevW ? opt_z : dNeigBedElevW;
		opt_cW = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigW])/pow(DOMAIN_DELTAX,1.5);

		if(!opt_pol_nx){
			ds_dt_data += manning_Solver(opt_h, opt_hW, opt_s,opt_sW,opt_zWmax,opt_cW);
		}else{
			printf("polini errorW: lIdxX %ld lIdxX %ld\n", lIdxX, lIdxY);
			flow_depth		 =  opt_s - opt_zWmax;
			flow_depth_neigh =  opt_sW- opt_zWmax;

			//noFlow
			if((flow_depth<=0.0 && flow_depth_neigh<=0.0) ||	(fabs(flow_depth-flow_depth_neigh)<=0.0)){
				ds_dt_buff=0.0;
			}
			else{ //Flow
				//flow out of this element without submerged weirflow reduction into the neihgbouring element
				if( flow_depth > 0.0 && flow_depth_neigh <= 0.0){
					ds_dt_buff = -1.0 * Cfacweir * opt_cW * pow(flow_depth, (3.0/2.0));

				}
				//flow out of the neighbouring element without submerged weirflow reduction into this element
				else if(flow_depth<= 0.0 && flow_depth_neigh > 0.0){

					ds_dt_buff = Cfacweir * opt_cW * pow(flow_depth_neigh,(3.0/2.0));
				}
				//submerged weirflow with reduction
				else if(flow_depth > 0.0 && flow_depth_neigh > 0.0){
					//flow out of this element into the neihgbouring element
					if(flow_depth>flow_depth_neigh){
						ds_dt_buff = Cfacweir * opt_cW * pow(flow_depth,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term = (1.0-flow_depth_neigh/flow_depth);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term <= 0.000463529){
							ds_dt_buff=-1.0 * ds_dt_buff * 0.057965266895 * atan(8984.365582471040 * reduction_term);
						}
						else{
							ds_dt_buff= -1.0 * ds_dt_buff * pow(reduction_term,(1.0/3.0));
						}

					}
					//flow out of the neighbouring element into this element
					else{
						ds_dt_buff = Cfacweir * opt_cW * pow(flow_depth_neigh,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term = (1.0 - flow_depth/flow_depth_neigh);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term <= 0.000463529){
							ds_dt_buff = ds_dt_buff * 0.057965266895 * atan(8984.365582471040 * reduction_term);
						}
						else{
							ds_dt_buff = ds_dt_buff * pow(reduction_term,(1.0/3.0));
						}

					}
				}
				//set the result
				ds_dt_data = ds_dt_data + ds_dt_buff;
			}
		}
	}

	
	//in y-direction
	if(!noflow_y){
		opt_hN = pNeigDataN - dNeigBedElevN;
		opt_sN = pNeigDataN;
		opt_zNmax = opt_z > dNeigBedElevN ? opt_z : dNeigBedElevN;
		opt_cN = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigN])/pow(DOMAIN_DELTAX,1.5);
		if(!opt_pol_y){
			ds_dt_data += manning_Solver(opt_h, opt_hN, opt_s,opt_sN,opt_zNmax,opt_cN);
		}else{
			printf("polini errorN: lIdxX %ld lIdxY %ld\n", lIdxX, lIdxY);
			flow_depth = opt_s-opt_zNmax;
			flow_depth_neigh = opt_sN - opt_zNmax;
		
			//noFlow
			if((flow_depth<=0.0 && flow_depth_neigh<=0.0) || (fabs(flow_depth-flow_depth_neigh)<=0.0)){
				ds_dt_buff=0.0;
			}
			//flow
			else{
				//flow out of this element without submerged weirflow reduction into the neihgbouring element
				if(flow_depth> 0.0 && flow_depth_neigh <= 0.0){
					ds_dt_buff=-1.0* Cfacweir *opt_cN*pow(flow_depth,(3.0/2.0));
				}
				//flow out of the neighbouring element without submerged weirflow reduction into this element
				else if(flow_depth<= 0.0 && flow_depth_neigh > 0.0){
					ds_dt_buff= Cfacweir *opt_cN*pow(flow_depth_neigh,(3.0/2.0));
				}
				//submerged weirflow with reduction
				else if(flow_depth > 0.0 && flow_depth_neigh > 0.0){
					//flow out of this element into the neihgbouring element
					if(flow_depth>flow_depth_neigh){
						ds_dt_buff= Cfacweir *opt_cN*pow(flow_depth,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term=(1.0-flow_depth_neigh/flow_depth);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term<=0.000463529){
							ds_dt_buff=-1.0*ds_dt_buff*0.057965266895*atan(8984.365582471040*reduction_term);
						}
						else{
							ds_dt_buff=-1.0*ds_dt_buff*pow(reduction_term,(1.0/3.0));
						}
					}
					//flow out of the neighbouring element into this element
					else{
						ds_dt_buff= Cfacweir *opt_cN*pow(flow_depth_neigh,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term=(1.0-flow_depth/flow_depth_neigh);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term<=0.000463529){
							ds_dt_buff=ds_dt_buff*0.057965266895*atan(8984.365582471040*reduction_term);
						}
						else{
							ds_dt_buff=ds_dt_buff*pow(reduction_term,(1.0/3.0));
						}
					}
				}

				//set result data
				ds_dt_data = ds_dt_data + ds_dt_buff;
			}
		}
	}

	if(!noflow_ny){
		opt_hS = pNeigDataS - dNeigBedElevS;
		opt_sS = pNeigDataS;
		opt_zSmax = opt_z > dNeigBedElevS ? opt_z : dNeigBedElevS;
		opt_cS = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigS])/pow(DOMAIN_DELTAX,1.5);
		if(!opt_pol_ny){
			ds_dt_data += manning_Solver(opt_h, opt_hS, opt_s,opt_sS,opt_zSmax,opt_cS);
		}else{
			printf("polini errorS: lIdxX %ld lIdxY %ld\n", lIdxX, lIdxY);
			flow_depth = opt_s-opt_zSmax;
			flow_depth_neigh = opt_sS - opt_zSmax;
		
			//noFlow
			if((flow_depth<=0.0 && flow_depth_neigh<=0.0) || (fabs(flow_depth-flow_depth_neigh)<=0.0)){
				ds_dt_buff=0.0;
			}
			//flow
			else{
				//flow out of this element without submerged weirflow reduction into the neihgbouring element
				if(flow_depth> 0.0 && flow_depth_neigh <= 0.0){
					ds_dt_buff=-1.0* Cfacweir *opt_cS*pow(flow_depth,(3.0/2.0));
				}
				//flow out of the neighbouring element without submerged weirflow reduction into this element
				else if(flow_depth<= 0.0 && flow_depth_neigh > 0.0){
					ds_dt_buff= Cfacweir *opt_cS*pow(flow_depth_neigh,(3.0/2.0));
				}
				//submerged weirflow with reduction
				else if(flow_depth > 0.0 && flow_depth_neigh > 0.0){
					//flow out of this element into the neihgbouring element
					if(flow_depth>flow_depth_neigh){
						ds_dt_buff= Cfacweir *opt_cS*pow(flow_depth,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term=(1.0-flow_depth_neigh/flow_depth);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term<=0.000463529){
							ds_dt_buff=-1.0*ds_dt_buff*0.057965266895*atan(8984.365582471040*reduction_term);
						}
						else{
							ds_dt_buff=-1.0*ds_dt_buff*pow(reduction_term,(1.0/3.0));
						}
					}
					//flow out of the neighbouring element into this element
					else{
						ds_dt_buff= Cfacweir *opt_cS*pow(flow_depth_neigh,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term=(1.0-flow_depth/flow_depth_neigh);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term<=0.000463529){
							ds_dt_buff=ds_dt_buff*0.057965266895*atan(8984.365582471040*reduction_term);
						}
						else{
							ds_dt_buff=ds_dt_buff*pow(reduction_term,(1.0/3.0));
						}
					}
				}

				//set result data
				ds_dt_data = ds_dt_data + ds_dt_buff;
			}
		}
	}
	
	
	// Update the flow state
	pCellData = pCellData	+ dLclTimestep * ds_dt_data;
	
	pCellStateDst[ulIdx] = pCellData;

}


cl_double manning_Solver(
	cl_double opt_h, 
	cl_double opt_h_Neig, 
	cl_double opt_s,
	cl_double opt_s_Neig,
	cl_double opt_zmax_Neig,
	cl_double opt_c_Neig)
	{

		cl_double flow_depth = 0;
		cl_double flow_depth_Neig;
		cl_double ds_dt_buff;
		cl_double delta_h;
		cl_double abs_delta_h;

		if(opt_h > VERY_SMALL || opt_h_Neig > VERY_SMALL){	
			
			flow_depth = opt_s - opt_zmaxNeig;
			flow_depth_Neig = max(0, opt_s - opt_zmaxNeig);
			flow_depth = max( flow_depth , flow_depth_Neig);

			if(flow_depth > VERY_SMALL){
				//diffusive wave
				delta_h = opt_s_Neig - opt_s;
				abs_delta_h=fabs(delta_h);

				if(abs_delta_h > VERY_SMALL){

					if(abs_delta_h<=0.005078){
						return opt_c_Neig * pow(flow_depth, (5.0/3.0))*0.10449968880528*atan(159.877741951379*delta_h); //0.0152
					}
					else{
						return opt_c_Neig * pow(flow_depth, (5.0/3.0)) *(delta_h/pow(abs_delta_h,0.5));
					}

					//set the result
					return 0;
				}
			}
		}

		return 0;
	}