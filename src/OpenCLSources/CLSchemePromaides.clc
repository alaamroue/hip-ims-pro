//#define DEBUG_OUTPUT
//#define DEBUG_CELLX 10
//#define DEBUG_CELLY 10

/*
 *  Calculate everything without using LDS caching
 */
__kernel REQD_WG_SIZE_FULL_TS
void gts_cacheDisabled ( 
			__constant	cl_double *  				dTimestep,					// Timestep
			__global	cl_double const * restrict	dBedElevation,				// Bed elevation
			__global	cl_double4 *  				pCellStateSrc,					// Current cell state data
			__global	cl_double4 *  				pCellStateDst,					// Current cell state data
			__global	cl_double const * restrict	dManning,					// Manning values
			__global	FlowStates const * restrict	flowstates,					// Flow States data
			__global	cl_double2 *  				pBoundCoup,						// Current Boundary Coupling data
			__global	cl_double *  				pds_dt,							// Current Boundary Coupling data
			__global	cl_double *  				BufferReadN,							// Current Boundary Coupling data
			__global	cl_double *  				BufferReadE,							// Current Boundary Coupling data
			__global	cl_double *  				BufferWriteN,							// Current Boundary Coupling data
			__global	cl_double *  				BufferWriteE							// Current Boundary Coupling data

		)
{
	// Identify the cell we're reconstructing (no overlap)
	__private cl_long					lIdxX			= get_global_id(0);
	__private cl_long					lIdxY			= get_global_id(1);
	__private cl_ulong					ulIdx, ulIdxNeigN, ulIdxNeigE, ulIdxNeigS, ulIdxNeigW;
	__private cl_uchar					ucDirection;
	
	ulIdx = getCellID(lIdxX, lIdxY);
	
	// Don't bother if we've gone beyond the domain bounds
	if ( lIdxX > DOMAIN_COLS - 1 || 
		lIdxY > DOMAIN_ROWS - 1 || 
		lIdxX < 0 || 
		lIdxY < 0 ){
		//printf("Went Beyoooond {%i, %i} {%ld,%ld}\n",DOMAIN_COLS,DOMAIN_ROWS,lIdxX,lIdxY);
		return;
		}


	__private cl_double		dLclTimestep	= *dTimestep;
	__private cl_double		dManningCoef;
	__private cl_double		dCellBedElev,dNeigBedElevN,dNeigBedElevE;
	__private cl_double		opt_h,opt_hN,opt_hE;
	__private cl_double		opt_cN, opt_cE;
	__private cl_double		opt_z, opt_zNmax, opt_zEmax;
	__private cl_double		opt_s, opt_sN, opt_sE;
	__private cl_double4	pCellData,pNeigDataN,pNeigDataE;
	

	__private cl_uchar		ucStop				=	0;
	__private cl_uchar		ucDryCount			=	0;
	__private cl_double		ds_dt_data			=	0.0;
	__private cl_double		flow_depth			=	0.0;
	__private cl_double		flow_depth_neigh	=	0.0;
	__private cl_double		delta_h				=	0.0;
	__private cl_double		abs_delta_h			=	0.0;
	__private cl_double		ds_dt_buff			=	0.0;
	__private cl_double		reduction_term		=	0.0;
	__private cl_double		v_x					=   0.0;
	__private cl_double		v_y					=   0.0;
	__private FlowStates	flowStateCell;

	//This would be passed as a variable
	flowStateCell = flowstates[ ulIdx ];

	bool isFlowElement	= flowStateCell.isFlowElement;
	bool noflow_x		= flowStateCell.noflow_x;
	bool noflow_y		= flowStateCell.noflow_y;
	bool opt_pol_x		= flowStateCell.opt_pol_x;
	bool opt_pol_y		= flowStateCell.opt_pol_y;

	//if (lIdxX==DOMAIN_COLS-1) {
	//	noflow_x = true;
	//}
	//if (lIdxY==DOMAIN_ROWS-1){
	//	noflow_y = true;
	//}

	// Also don't bother if we've gone beyond the total simulation time
	if (dLclTimestep <= 0.0)
	{
		//printf("90, ulIdx: %f dLclTimestep: %f \n",ulIdx*1.0, dLclTimestep);
		// TODO: Is there a way of avoiding this?!
		pCellStateDst[ulIdx] = pCellStateSrc[ulIdx];
		return;
	}

	// Load cell data
	dCellBedElev		= dBedElevation[ ulIdx ];
	pCellData			= pCellStateSrc[ ulIdx ];
	dManningCoef		= dManning[ ulIdx ];

	// Cell disabled?
	if ( pCellData.y <= -9999.0 || pCellData.x == -9999.0 || !isFlowElement)
	{
		printf("104/n");
		pCellStateDst[ ulIdx ] = pCellData;
		return;
	}


	
	ulIdxNeigN = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_N);
	dNeigBedElevN	= dBedElevation [ ulIdxNeigN ];
	pNeigDataN		= pCellStateSrc	[ ulIdxNeigN ];

	ulIdxNeigE = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_E);
	dNeigBedElevE	= dBedElevation [ ulIdxNeigE ];
	pNeigDataE		= pCellStateSrc	[ ulIdxNeigE ];

	//set data
	opt_z = dCellBedElev;
	opt_h = pCellData.x  - opt_z;
	opt_s = pCellData.x;

	if(opt_pol_x || opt_pol_y){
		printf("We shouldn't be here xxxxxxxxxxxxxxxxx \n");
	//	return;
	}

	opt_hE = pNeigDataE.x - dNeigBedElevE;
	opt_sE = pNeigDataE.x;
	opt_zEmax = opt_z > dNeigBedElevE ? opt_z : dNeigBedElevE;
	opt_cE = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigE])/pow(DOMAIN_DELTAX,1.5);

	opt_hN = pNeigDataN.x - dNeigBedElevN;
	opt_sN = pNeigDataN.x;
	opt_zNmax = opt_z > dNeigBedElevN ? opt_z : dNeigBedElevN;
	opt_cN = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigN])/pow(DOMAIN_DELTAX,1.5);


	//in x-direction
	if(!noflow_x){
		if(!opt_pol_x){
			//manning x
			if(opt_h > VERY_SMALL || opt_hE > VERY_SMALL){
				
				flow_depth = opt_s - opt_zEmax;
				if(flow_depth <0.0){
					flow_depth=0.0;
				}
				flow_depth_neigh = opt_sE - opt_zEmax;
				if(flow_depth_neigh<0.0){
					flow_depth_neigh=0.0;
				}

				flow_depth=max(flow_depth,flow_depth_neigh);

				ds_dt_buff=0;
				if(flow_depth > VERY_SMALL){
					//diffusive wave
					delta_h= opt_sE - opt_s;
					abs_delta_h=fabs(delta_h);

					if(abs_delta_h > VERY_SMALL){
						ds_dt_buff= opt_cE * pow(flow_depth, (5.0/3.0));

						if(abs_delta_h<=0.005078){
							ds_dt_buff=ds_dt_buff*0.10449968880528*atan(159.877741951379*delta_h); //0.0152
						}
						else{
							ds_dt_buff=ds_dt_buff*(delta_h/pow(abs_delta_h,0.5));
						}

						//set the result
						ds_dt_data	+= ds_dt_buff;
						BufferWriteE[ulIdxNeigE] = ds_dt_buff*dLclTimestep;
					}
				}
			}
		}
	}

	//in y-direction
	if(!noflow_y){
		if(!opt_pol_y){
			if( opt_h > VERY_SMALL ||  opt_hN > VERY_SMALL){
				//calculate the mid of the flow depth
				flow_depth= opt_s - opt_zNmax;
				if(flow_depth <0.0){
					flow_depth=0.0;
				}
				flow_depth_neigh= opt_sN - opt_zNmax;
				if(flow_depth_neigh<0.0){
					flow_depth_neigh=0.0;
				}
				//flow_depth=(flow_depth+flow_depth_neigh)*0.5;
				flow_depth=max(flow_depth,flow_depth_neigh);
			
				ds_dt_buff=0;
				if(flow_depth > VERY_SMALL){
					//diffusive wave
					delta_h= opt_sN- opt_s;
					abs_delta_h=fabs(delta_h);

					if(abs_delta_h > VERY_SMALL){
						ds_dt_buff = opt_cN * pow(flow_depth, (5.0/3.0));

						if(abs_delta_h<=0.005078){
							ds_dt_buff *= 0.10449968880528*atan(159.877741951379*delta_h); //0.0152
						}
						else{
							ds_dt_buff *= delta_h/pow(abs_delta_h,0.5);
						}

						//set the result
						ds_dt_data	+= ds_dt_buff;
						BufferWriteN[ulIdxNeigN] = ds_dt_buff*dLclTimestep;
					}
				}
			}
		}
	}
	
	// Update the flow state
	pCellData.x		= pCellData.x	+ dLclTimestep * ds_dt_data;
	pCellData.z		= v_x;
	pCellData.w		= v_y;

	//pNeigDataN.x		= pNeigDataN.x	- dLclTimestep * ds_dt_dataN;
	//pNeigDataE.x		= pNeigDataE.x	- dLclTimestep * ds_dt_dataE;

	// New max FSL?
	if ( pCellData.x > pCellData.y && pCellData.y > -9990.0 )
		pCellData.y = pCellData.x;


	if ( lIdxX == 0 && lIdxY == 0)
	{	
		//printf("x: %f y: %f z: %f w: %f ds_dt_data %f  ts %f\n", pCellData.x-opt_z, pCellData.y-opt_z, pCellData.z, pCellData.w, ds_dt_data, dLclTimestep);
	}

	// Commit to global memory
	pds_dt[ulIdx] += ds_dt_data + pBoundCoup[ulIdx].x;
	

	
	pCellStateDst[ulIdx] = pCellData;


}
