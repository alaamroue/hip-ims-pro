//#define DEBUG_OUTPUT
//#define DEBUG_CELLX 10
//#define DEBUG_CELLY 10

/*
 *  Calculate everything without using LDS caching
 */
__kernel REQD_WG_SIZE_FULL_TS
void gts_cacheDisabled ( 
			__constant	cl_double *  				dTimestep,					// Timestep
			__global	cl_double const * restrict	dBedElevation,				// Bed elevation
			__global	cl_double4 *  				pCellStateSrc,					// Current cell state data
			__global	cl_double4 *  				pCellStateDst,					// Current cell state data
			__global	cl_double const * restrict	dManning,					// Manning values
			__global	FlowStates const * restrict	flowstates,					// Flow States data
			__global	cl_double2 *  				pBoundCoup,						// Current Boundary Coupling data
			__global	cl_double *  				pds_dt							// Current Boundary Coupling data
		)
{

	// Identify the cell we're reconstructing (no overlap)
	__private cl_long					lIdxX			= get_global_id(0);
	__private cl_long					lIdxY			= get_global_id(1);
	__private cl_ulong					ulIdx, ulIdxNeigN, ulIdxNeigE, ulIdxNeigS, ulIdxNeigW;
	__private cl_uchar					ucDirection;
	
	ulIdx = getCellID(lIdxX, lIdxY);
	
	// Don't bother if we've gone beyond the domain bounds
	if ( lIdxX > DOMAIN_COLS - 1 || 
		lIdxY > DOMAIN_ROWS - 1 || 
		lIdxX < 0 || 
		lIdxY < 0 ){
		//printf("Went Beyoooond {%i, %i} {%ld,%ld}\n",DOMAIN_COLS,DOMAIN_ROWS,lIdxX,lIdxY);
		return;
		}


	__private cl_double		dLclTimestep	= *dTimestep;
	__private cl_double		dManningCoef;
	__private cl_double		dCellBedElev,dNeigBedElevN,dNeigBedElevE,dNeigBedElevS,dNeigBedElevW;
	__private cl_double		opt_h,opt_hN,opt_hE,opt_hS,opt_hW;
	__private cl_double		opt_cN, opt_cE, opt_cS, opt_cW;
	__private cl_double		opt_z, opt_zNmax, opt_zEmax, opt_zSmax, opt_zWmax;
	__private cl_double		opt_s, opt_sN, opt_sE,opt_sS,opt_sW;
	__private cl_double4	pCellData,pNeigDataN,pNeigDataE,pNeigDataS,pNeigDataW;
	

	__private cl_uchar		ucStop				=	0;
	__private cl_uchar		ucDryCount			=	0;
	__private cl_double		ds_dt_data			=	0.0;
	__private cl_double		flow_depth			=	0.0;
	__private cl_double		flow_depth_neigh	=	0.0;
	__private cl_double		delta_h				=	0.0;
	__private cl_double		abs_delta_h			=	0.0;
	__private cl_double		ds_dt_buff			=	0.0;
	__private cl_double		reduction_term		=	0.0;
	__private cl_double		v_x					=   0.0;
	__private cl_double		v_y					=   0.0;
	__private FlowStates	flowStateCell;

	//This would be passed as a variable
	flowStateCell = flowstates[ ulIdx ];

	bool isFlowElement	= flowStateCell.isFlowElement;
	bool noflow_x		= flowStateCell.noflow_x;
	bool noflow_y		= flowStateCell.noflow_y;
	noflow_x			= false;
	noflow_y			= false;
	bool opt_pol_x		= flowStateCell.opt_pol_x;
	bool opt_pol_y		= flowStateCell.opt_pol_y;

	//if (lIdxX==DOMAIN_COLS-1) {
	//	noflow_x = true;
	//}
	//if (lIdxY==DOMAIN_ROWS-1){
	//	noflow_y = true;
	//}

	// Also don't bother if we've gone beyond the total simulation time
	if (dLclTimestep <= 0.0)
	{
		//printf("90, ulIdx: %f dLclTimestep: %f \n",ulIdx*1.0, dLclTimestep);
		// TODO: Is there a way of avoiding this?!
		pCellStateDst[ulIdx] = pCellStateSrc[ulIdx];
		return;
	}

	// Load cell data
	dCellBedElev		= dBedElevation[ ulIdx ];
	pCellData			= pCellStateSrc[ ulIdx ];
	dManningCoef		= dManning[ ulIdx ];

	// Cell disabled?
	if ( pCellData.y <= -9999.0 || pCellData.x == -9999.0 )
	{
		//printf("104/n");
		pCellStateDst[ ulIdx ] = pCellData;
		return;
	}


	
	ulIdxNeigN = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_N);
	dNeigBedElevN	= dBedElevation [ ulIdxNeigN ];
	pNeigDataN		= pCellStateSrc	[ ulIdxNeigN ];

	ulIdxNeigE = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_E);
	dNeigBedElevE	= dBedElevation [ ulIdxNeigE ];
	pNeigDataE		= pCellStateSrc	[ ulIdxNeigE ];

	ulIdxNeigS = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_S);
	dNeigBedElevS	= dBedElevation [ ulIdxNeigS ];
	pNeigDataS		= pCellStateSrc	[ ulIdxNeigS ];

	ulIdxNeigW = getNeighbourByIndices(lIdxX, lIdxY, DOMAIN_DIR_W);
	dNeigBedElevW	= dBedElevation [ ulIdxNeigW ];
	pNeigDataW		= pCellStateSrc	[ ulIdxNeigW ];


	//set data
	opt_z = dCellBedElev;
	//if((pCellData.x  - opt_z) < VERY_SMALL){
	//	opt_h = 0.0;
	//	opt_s = opt_z;
	//}else{
		opt_h = pCellData.x  - opt_z;
		opt_s = pCellData.x;
	//}
	

	//Add Boundry and couple conditions
	//ds_dt_data = bound_cond_dsdt + coup_cond_dsdt;
	//ds_dt_data = 10.0/dLclTimestep*0;

	//opt_h = pCellData.x  - dCellBedElev;
	
	
	
	
	
	

	//v_x = pCellData.z;
	//v_y = pCellData.w;

	if(opt_pol_x || opt_pol_y){
		printf("We shouldn't be here xxxxxxxxxxxxxxxxx \n");
	//	return;
	}


	if(!(lIdxX==DOMAIN_ROWS-1)){
	opt_hE = pNeigDataE.x - dNeigBedElevE;
	opt_sE = pNeigDataE.x;
	opt_zEmax = opt_z > dNeigBedElevE ? opt_z : dNeigBedElevE;
	opt_cE = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigE])/pow(DOMAIN_DELTAX,1.5);
	//in x-direction
	if(!noflow_x){
		if(!opt_pol_x){
			//manning x
			if(opt_h > VERY_SMALL || opt_hE > VERY_SMALL){
				
				flow_depth = opt_s - opt_zEmax;
				if(flow_depth <0.0){
					flow_depth=0.0;
				}
				flow_depth_neigh = opt_sE - opt_zEmax;
				if(flow_depth_neigh<0.0){
					flow_depth_neigh=0.0;
				}

				flow_depth=max(flow_depth,flow_depth_neigh);
				if ( lIdxX == 88 && lIdxY == 88)
				{	
					//printf("dLclTimestep %f flow_depth %f flow_depth_neigh %f\n",dLclTimestep, opt_s, opt_sE);
				}

				ds_dt_buff=0;
				if(flow_depth > VERY_SMALL){
					//diffusive wave
					delta_h= opt_sE - opt_s;
					abs_delta_h=fabs(delta_h);

					if(abs_delta_h > VERY_SMALL){
						ds_dt_buff= opt_cE * pow(flow_depth, (5.0/3.0));

						if(abs_delta_h<=0.005078){
							ds_dt_buff=ds_dt_buff*0.10449968880528*atan(159.877741951379*delta_h); //0.0152
						}
						else{
							ds_dt_buff=ds_dt_buff*(delta_h/pow(abs_delta_h,0.5));
						}

						//set the result
						ds_dt_data	+= ds_dt_buff;
						//printf("ds_dt_buff: %f \n" ,ds_dt_buff);
						v_x			+= -1* ds_dt_buff * DOMAIN_DELTAX / flow_depth;
					}
				}
			}
		}else{
			printf("polini errorE: lIdxX %ld lIdxX %ld\n", lIdxX, lIdxY);
			flow_depth		 =  opt_s - opt_zEmax;
			flow_depth_neigh =  opt_sE- opt_zEmax;

			//noFlow
			if((flow_depth<=0.0 && flow_depth_neigh<=0.0) ||	(fabs(flow_depth-flow_depth_neigh)<=0.0)){
				ds_dt_buff=0.0;
			}
			else{ //Flow
				//flow out of this element without submerged weirflow reduction into the neihgbouring element
				if( flow_depth > 0.0 && flow_depth_neigh <= 0.0){
					ds_dt_buff = -1.0 * Cfacweir * opt_cE * pow(flow_depth, (3.0/2.0));

					v_x = -1.0 * ds_dt_buff * DOMAIN_DELTAX / flow_depth;
				}
				//flow out of the neighbouring element without submerged weirflow reduction into this element
				else if(flow_depth<= 0.0 && flow_depth_neigh > 0.0){

					ds_dt_buff = Cfacweir * opt_cE * pow(flow_depth_neigh,(3.0/2.0));
					v_x = -1.0 * ds_dt_buff * DOMAIN_DELTAX / flow_depth_neigh;
				}
				//submerged weirflow with reduction
				else if(flow_depth > 0.0 && flow_depth_neigh > 0.0){
					//flow out of this element into the neihgbouring element
					if(flow_depth>flow_depth_neigh){
						ds_dt_buff = Cfacweir * opt_cE * pow(flow_depth,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term = (1.0-flow_depth_neigh/flow_depth);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term <= 0.000463529){
							ds_dt_buff=-1.0 * ds_dt_buff * 0.057965266895 * atan(8984.365582471040 * reduction_term);
						}
						else{
							ds_dt_buff= -1.0 * ds_dt_buff * pow(reduction_term,(1.0/3.0));
						}

						v_x = -1.0 * ds_dt_buff * DOMAIN_DELTAX / flow_depth;
					}
					//flow out of the neighbouring element into this element
					else{
						ds_dt_buff = Cfacweir * opt_cE * pow(flow_depth_neigh,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term = (1.0 - flow_depth/flow_depth_neigh);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term <= 0.000463529){
							ds_dt_buff = ds_dt_buff * 0.057965266895 * atan(8984.365582471040 * reduction_term);
						}
						else{
							ds_dt_buff = ds_dt_buff * pow(reduction_term,(1.0/3.0));
						}

						v_x = -1.0 * ds_dt_buff * DOMAIN_DELTAX / flow_depth_neigh;
					}
				}
				//set the result
				ds_dt_data = ds_dt_data + ds_dt_buff;
			}
		}
	}
	}
	
	if(!(lIdxX==0)){
	opt_hW = pNeigDataW.x - dNeigBedElevW;
	opt_sW = pNeigDataW.x;
	opt_zWmax = opt_z > dNeigBedElevW ? opt_z : dNeigBedElevW;
	opt_cW = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigW])/pow(DOMAIN_DELTAX,1.5);
	//in -x-direction
	if(!noflow_x){

		if(!opt_pol_x){
			//manning x
			if(opt_h > VERY_SMALL || opt_hW > VERY_SMALL){
				


				flow_depth = opt_s - opt_zWmax;
				if(flow_depth <0.0){
					flow_depth=0.0;
				}
				flow_depth_neigh= opt_sW - opt_zWmax;
				if(flow_depth_neigh<0.0){
					flow_depth_neigh=0.0;
				}

				flow_depth=max(flow_depth,flow_depth_neigh);

				ds_dt_buff=0;
				if(flow_depth > VERY_SMALL){
					//diffusive wave
					delta_h= opt_sW - opt_s;
					abs_delta_h=fabs(delta_h);

					if(abs_delta_h > VERY_SMALL){
						ds_dt_buff= opt_cW * pow(flow_depth, (5.0/3.0));

						if(abs_delta_h<=0.005078){
							ds_dt_buff=ds_dt_buff*0.10449968880528*atan(159.877741951379*delta_h); //0.0152
						}
						else{
							ds_dt_buff=ds_dt_buff*(delta_h/pow(abs_delta_h,0.5));
						}

						//set the result
						ds_dt_data	+= ds_dt_buff;
						v_x			+= ds_dt_buff * DOMAIN_DELTAX / flow_depth;
					}
				}
			}
		}else{
			printf("polini errorW: lIdxX %ld lIdxX %ld\n", lIdxX, lIdxY);
			flow_depth		 =  opt_s - opt_zWmax;
			flow_depth_neigh =  opt_sW- opt_zWmax;

			//noFlow
			if((flow_depth<=0.0 && flow_depth_neigh<=0.0) ||	(fabs(flow_depth-flow_depth_neigh)<=0.0)){
				ds_dt_buff=0.0;
			}
			else{ //Flow
				//flow out of this element without submerged weirflow reduction into the neihgbouring element
				if( flow_depth > 0.0 && flow_depth_neigh <= 0.0){
					ds_dt_buff = -1.0 * Cfacweir * opt_cW * pow(flow_depth, (3.0/2.0));

					v_x += -1.0 * ds_dt_buff * DOMAIN_DELTAX / flow_depth;
				}
				//flow out of the neighbouring element without submerged weirflow reduction into this element
				else if(flow_depth<= 0.0 && flow_depth_neigh > 0.0){

					ds_dt_buff = Cfacweir * opt_cW * pow(flow_depth_neigh,(3.0/2.0));
					v_x += -1.0 * ds_dt_buff * DOMAIN_DELTAX / flow_depth_neigh;
				}
				//submerged weirflow with reduction
				else if(flow_depth > 0.0 && flow_depth_neigh > 0.0){
					//flow out of this element into the neihgbouring element
					if(flow_depth>flow_depth_neigh){
						ds_dt_buff = Cfacweir * opt_cW * pow(flow_depth,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term = (1.0-flow_depth_neigh/flow_depth);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term <= 0.000463529){
							ds_dt_buff=-1.0 * ds_dt_buff * 0.057965266895 * atan(8984.365582471040 * reduction_term);
						}
						else{
							ds_dt_buff= -1.0 * ds_dt_buff * pow(reduction_term,(1.0/3.0));
						}

						v_x += -1.0 * ds_dt_buff * DOMAIN_DELTAX / flow_depth;
					}
					//flow out of the neighbouring element into this element
					else{
						ds_dt_buff = Cfacweir * opt_cW * pow(flow_depth_neigh,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term = (1.0 - flow_depth/flow_depth_neigh);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term <= 0.000463529){
							ds_dt_buff = ds_dt_buff * 0.057965266895 * atan(8984.365582471040 * reduction_term);
						}
						else{
							ds_dt_buff = ds_dt_buff * pow(reduction_term,(1.0/3.0));
						}

						v_x += -1.0 * ds_dt_buff * DOMAIN_DELTAX / flow_depth_neigh;
					}
				}
				//set the result
				ds_dt_data = ds_dt_data + ds_dt_buff;
			}
		}
	}else{
	}
	}

	
	if(!(lIdxY==DOMAIN_COLS-1)){
	opt_hN = pNeigDataN.x - dNeigBedElevN;
	opt_sN = pNeigDataN.x;
	opt_zNmax = opt_z > dNeigBedElevN ? opt_z : dNeigBedElevN;
	opt_cN = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigN])/pow(DOMAIN_DELTAX,1.5);
	//in y-direction
	if(!noflow_y){
		if(!opt_pol_y){

			if( opt_h > VERY_SMALL ||  opt_hN > VERY_SMALL){
				//calculate the mid of the flow depth
				flow_depth= opt_s - opt_zNmax;
				if(flow_depth <0.0){
					flow_depth=0.0;
				}
				flow_depth_neigh= opt_sN - opt_zNmax;
				if(flow_depth_neigh<0.0){
					flow_depth_neigh=0.0;
				}
				//flow_depth=(flow_depth+flow_depth_neigh)*0.5;
				flow_depth=max(flow_depth,flow_depth_neigh);
			
				ds_dt_buff=0;
				if(flow_depth > VERY_SMALL){
					//diffusive wave
					delta_h= opt_sN- opt_s;
					abs_delta_h=fabs(delta_h);

					if(abs_delta_h > VERY_SMALL){
						ds_dt_buff = opt_cN * pow(flow_depth, (5.0/3.0));

						if(abs_delta_h<=0.005078){
							ds_dt_buff *= 0.10449968880528*atan(159.877741951379*delta_h); //0.0152
						}
						else{
							ds_dt_buff *= delta_h/pow(abs_delta_h,0.5);
						}

						//set the result
						ds_dt_data	+= ds_dt_buff;
						v_y			+= -1* ds_dt_buff * DOMAIN_DELTAY / flow_depth;
					}
				}
			}
		}else{
			printf("polini errorN: lIdxX %ld lIdxY %ld\n", lIdxX, lIdxY);
			flow_depth = opt_s-opt_zNmax;
			flow_depth_neigh = opt_sN - opt_zNmax;
		
			//noFlow
			if((flow_depth<=0.0 && flow_depth_neigh<=0.0) || (fabs(flow_depth-flow_depth_neigh)<=0.0)){
				ds_dt_buff=0.0;
			}
			//flow
			else{
				//flow out of this element without submerged weirflow reduction into the neihgbouring element
				if(flow_depth> 0.0 && flow_depth_neigh <= 0.0){
					ds_dt_buff=-1.0* Cfacweir *opt_cN*pow(flow_depth,(3.0/2.0));
					v_y = -1.0 * ds_dt_buff * DOMAIN_DELTAY / flow_depth;
				}
				//flow out of the neighbouring element without submerged weirflow reduction into this element
				else if(flow_depth<= 0.0 && flow_depth_neigh > 0.0){
					ds_dt_buff= Cfacweir *opt_cN*pow(flow_depth_neigh,(3.0/2.0));
					v_y = -1.0 * ds_dt_buff * DOMAIN_DELTAY / flow_depth_neigh;
				}
				//submerged weirflow with reduction
				else if(flow_depth > 0.0 && flow_depth_neigh > 0.0){
					//flow out of this element into the neihgbouring element
					if(flow_depth>flow_depth_neigh){
						ds_dt_buff= Cfacweir *opt_cN*pow(flow_depth,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term=(1.0-flow_depth_neigh/flow_depth);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term<=0.000463529){
							ds_dt_buff=-1.0*ds_dt_buff*0.057965266895*atan(8984.365582471040*reduction_term);
						}
						else{
							ds_dt_buff=-1.0*ds_dt_buff*pow(reduction_term,(1.0/3.0));
						}
						v_y = -1.0 * ds_dt_buff * DOMAIN_DELTAY / flow_depth;
					}
					//flow out of the neighbouring element into this element
					else{
						ds_dt_buff= Cfacweir *opt_cN*pow(flow_depth_neigh,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term=(1.0-flow_depth/flow_depth_neigh);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term<=0.000463529){
							ds_dt_buff=ds_dt_buff*0.057965266895*atan(8984.365582471040*reduction_term);
						}
						else{
							ds_dt_buff=ds_dt_buff*pow(reduction_term,(1.0/3.0));
						}
						v_y = -1.0 * ds_dt_buff * DOMAIN_DELTAY / flow_depth_neigh;
					}
				}

				//set result data
				ds_dt_data = ds_dt_data + ds_dt_buff;
			}
		}
	}
	}
	
	if(!(lIdxY==0)){
	opt_hS = pNeigDataS.x - dNeigBedElevS;
	opt_sS = pNeigDataS.x;
	opt_zSmax = opt_z > dNeigBedElevS ? opt_z : dNeigBedElevS;
	opt_cS = 0.5*(1 / dManning[ulIdx] + 1 / dManning[ulIdxNeigS])/pow(DOMAIN_DELTAX,1.5);
	//in -y-direction
	if(!noflow_y){
		if(!opt_pol_y){

			if( opt_h > VERY_SMALL ||  opt_hS > VERY_SMALL){
				//calculate the mid of the flow depth
				flow_depth= opt_s - opt_zSmax;
				if(flow_depth <0.0){
					flow_depth=0.0;
				}
				flow_depth_neigh= opt_sS - opt_zSmax;
				if(flow_depth_neigh<0.0){
					flow_depth_neigh=0.0;
				}
				//flow_depth=(flow_depth+flow_depth_neigh)*0.5;
				flow_depth=max(flow_depth,flow_depth_neigh);
			
				ds_dt_buff=0;
				if(flow_depth > VERY_SMALL){
					//diffusive wave
					delta_h= opt_sS - opt_s;
					abs_delta_h=fabs(delta_h);

					if(abs_delta_h > VERY_SMALL){
						ds_dt_buff= opt_cS*pow(flow_depth, (5.0/3.0));

						if(abs_delta_h<=0.005078){
							ds_dt_buff *= 0.10449968880528*atan(159.877741951379*delta_h); //0.0152
						}
						else{
							ds_dt_buff *= delta_h/pow(abs_delta_h,0.5);
						}

						//set the result
						ds_dt_data	+= ds_dt_buff;

						v_y			+= ds_dt_buff * DOMAIN_DELTAY / flow_depth;
					}
				}
			}
		}else{
			printf("polini errorS: lIdxX %ld lIdxY %ld\n", lIdxX, lIdxY);
			flow_depth = opt_s-opt_zSmax;
			flow_depth_neigh = opt_sS - opt_zSmax;
		
			//noFlow
			if((flow_depth<=0.0 && flow_depth_neigh<=0.0) || (fabs(flow_depth-flow_depth_neigh)<=0.0)){
				ds_dt_buff=0.0;
			}
			//flow
			else{
				//flow out of this element without submerged weirflow reduction into the neihgbouring element
				if(flow_depth> 0.0 && flow_depth_neigh <= 0.0){
					ds_dt_buff=-1.0* Cfacweir *opt_cS*pow(flow_depth,(3.0/2.0));
					v_y += -1.0 * ds_dt_buff * DOMAIN_DELTAY / flow_depth;
				}
				//flow out of the neighbouring element without submerged weirflow reduction into this element
				else if(flow_depth<= 0.0 && flow_depth_neigh > 0.0){
					ds_dt_buff= Cfacweir *opt_cS*pow(flow_depth_neigh,(3.0/2.0));
					v_y += -1.0 * ds_dt_buff * DOMAIN_DELTAY / flow_depth_neigh;
				}
				//submerged weirflow with reduction
				else if(flow_depth > 0.0 && flow_depth_neigh > 0.0){
					//flow out of this element into the neihgbouring element
					if(flow_depth>flow_depth_neigh){
						ds_dt_buff= Cfacweir *opt_cS*pow(flow_depth,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term=(1.0-flow_depth_neigh/flow_depth);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term<=0.000463529){
							ds_dt_buff=-1.0*ds_dt_buff*0.057965266895*atan(8984.365582471040*reduction_term);
						}
						else{
							ds_dt_buff=-1.0*ds_dt_buff*pow(reduction_term,(1.0/3.0));
						}
						v_y += -1.0 * ds_dt_buff * DOMAIN_DELTAY / flow_depth;
					}
					//flow out of the neighbouring element into this element
					else{
						ds_dt_buff= Cfacweir *opt_cS*pow(flow_depth_neigh,(3.0/2.0));
						//reduction of the discharge (submerged weirflow)
						reduction_term=(1.0-flow_depth/flow_depth_neigh);
						//replace the ^(1/3) by a fitted arctan-function; at the boundary they have the same values
						if(reduction_term<=0.000463529){
							ds_dt_buff=ds_dt_buff*0.057965266895*atan(8984.365582471040*reduction_term);
						}
						else{
							ds_dt_buff=ds_dt_buff*pow(reduction_term,(1.0/3.0));
						}
						v_y += -1.0 * ds_dt_buff * DOMAIN_DELTAY / flow_depth_neigh;
					}
				}

				//set result data
				ds_dt_data = ds_dt_data + ds_dt_buff;
			}
		}
	}
	}


	// Update the flow state
	pCellData.x		= pCellData.x	+ dLclTimestep * ds_dt_data;
	pCellData.z		= v_x;
	pCellData.w		= v_y;

	//pNeigDataN.x		= pNeigDataN.x	- dLclTimestep * ds_dt_dataN;
	//pNeigDataE.x		= pNeigDataE.x	- dLclTimestep * ds_dt_dataE;

	// New max FSL?
	if ( pCellData.x > pCellData.y && pCellData.y > -9990.0 )
		pCellData.y = pCellData.x;

	// Crazy low depths?
	//if ( pCellData.x - dCellBedElev < VERY_SMALL*100000 )
	//	pCellData.x = dCellBedElev;


	if ( lIdxX == 0 && lIdxY == 0)
	{	
		//printf("x: %f y: %f z: %f w: %f ds_dt_data %f  ts %f\n", pCellData.x-opt_z, pCellData.y-opt_z, pCellData.z, pCellData.w, ds_dt_data, dLclTimestep);
	}

	// Commit to global memory
	pds_dt[ulIdx] += ds_dt_data + pBoundCoup[ulIdx].x;
	

	
	pCellStateDst[ulIdx] = pCellData;


}
