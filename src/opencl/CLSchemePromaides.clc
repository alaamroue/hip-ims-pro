/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  INERTIAL SCHEME
 * ------------------------------------------
 *  Implementation of the simplified inertial
 *  scheme
 * ------------------------------------------
 *
 */

/*
 *  Calculate everything without using LDS caching
 */
__kernel REQD_WG_SIZE_FULL_TS
void pro_cacheDisabled ( 
			__constant	cl_double *  				dTimestep,						// Timestep
			__global	cl_double const * restrict	dBedElevation,					// Bed elevation
			__global	cl_double4 *  			pCellStateSrc,					// Current cell state data
			__global	cl_double4 *  			pCellStateDst,					// Current cell state data
			__global	cl_double const * restrict	dManning						// Manning values
		)
{

	// Identify the cell we're reconstructing (no overlap)
	__private cl_long					lIdxX			= get_global_id(0);
	__private cl_long					lIdxY			= get_global_id(1);
	__private cl_ulong					ulIdx, ulIdxNeig;
	__private cl_uchar					ucDirection;
	
	ulIdx = getCellID(lIdxX, lIdxY);

	// Don't bother if we've gone beyond the domain bounds
	if ( lIdxX >= DOMAIN_COLS - 1 || 
		 lIdxY >= DOMAIN_ROWS - 1 || 
		 lIdxX <= 0 || 
		 lIdxY <= 0 ) 
		return;

	__private cl_double		dLclTimestep	= *dTimestep;
	__private cl_double		dManningCoef, dDeltaFSL, pNeigManN, pNeigManE, pNeigManS,pNeigManW;
	__private cl_double		dCellBedElev,dNeigBedElevN,dNeigBedElevE,dNeigBedElevS,dNeigBedElevW;
	__private cl_double4	pCellData,pNeigDataN,pNeigDataE,pNeigDataS,pNeigDataW;					// Z, Zmax, Qx, Qy
	__private cl_double2	dDischarges[4];															// Qn, Qe, Qs, Qw
	__private cl_uchar		ucDryCount		= 0;
	

	// Also don't bother if we've gone beyond the total simulation time
	if ( dLclTimestep <= 0.0 )
		return;

	// Load cell data
	dCellBedElev		= dBedElevation[ ulIdx ];
	pCellData			= pCellStateSrc[ ulIdx ];
	dManningCoef		= dManning[ ulIdx ];

	// Cell disabled?
	if ( pCellData.y <= -9999.0 || pCellData.x == -9999.0 )
	{
		pCellStateDst[ ulIdx ] = pCellData;
		return;
	}

	ucDirection = DOMAIN_DIR_W;
	ulIdxNeig = getNeighbourByIndices(lIdxX, lIdxY, ucDirection);
	dNeigBedElevW	= dBedElevation [ ulIdxNeig ];
	pNeigDataW		= pCellStateSrc	[ ulIdxNeig ];
	pNeigManW		= dManning [ ulIdxNeig ];
	ucDirection = DOMAIN_DIR_S;
	ulIdxNeig = getNeighbourByIndices(lIdxX, lIdxY, ucDirection);
	dNeigBedElevS	= dBedElevation [ ulIdxNeig ];
	pNeigDataS		= pCellStateSrc	[ ulIdxNeig ];
	pNeigManS		= dManning [ ulIdxNeig ];
	ucDirection = DOMAIN_DIR_N;
	ulIdxNeig = getNeighbourByIndices(lIdxX, lIdxY, ucDirection);
	dNeigBedElevN	= dBedElevation [ ulIdxNeig ];
	pNeigDataN		= pCellStateSrc	[ ulIdxNeig ];
	pNeigManN		= dManning [ ulIdxNeig ];
	ucDirection = DOMAIN_DIR_E;
	ulIdxNeig = getNeighbourByIndices(lIdxX, lIdxY, ucDirection);
	dNeigBedElevE	= dBedElevation [ ulIdxNeig ];
	pNeigDataE		= pCellStateSrc	[ ulIdxNeig ];
	pNeigManE		= dManning [ ulIdxNeig ];

	if ( pCellData.x  - dCellBedElev  < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataN.x - dNeigBedElevN < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataE.x - dNeigBedElevE < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataS.x - dNeigBedElevS < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataW.x - dNeigBedElevW < VERY_SMALL ) ucDryCount++;

	// All neighbours are dry? Don't bother calculating
	if ( ucDryCount >= 5 ) return;
	
	bool debug = false;
	if(ulIdx==9696){
	//	debug = true;
	}
	// Calculate fluxes
	// -> North
	dDischarges[ DOMAIN_DIR_N ] = manning_Solver(
		dLclTimestep,
		dManningCoef,
		pNeigManN,
		pCellData.x,
		pNeigDataN.x,
		dCellBedElev,
		dNeigBedElevN,
		debug
	);

	// -> East
	dDischarges[ DOMAIN_DIR_E ] = manning_Solver(
		dLclTimestep,
		dManningCoef,
		pNeigManE,
		pCellData.x,
		pNeigDataE.x,
		dCellBedElev,
		dNeigBedElevE,
		debug
	);
	// -> South
	dDischarges[ DOMAIN_DIR_S ] = manning_Solver(
		dLclTimestep,
		dManningCoef,
		pNeigManS,
		pCellData.x,
		pNeigDataS.x,
		dCellBedElev,
		dNeigBedElevS,
		debug
	);
	// -> West
	dDischarges[ DOMAIN_DIR_W ] = manning_Solver(
		dLclTimestep,
		dManningCoef,
		pNeigManW,
		pCellData.x,
		pNeigDataW.x,
		dCellBedElev,
		dNeigBedElevW,
		debug
	);

	if(lIdxX == DOMAIN_ROWS - 2 ){
		dDischarges[DOMAIN_DIR_E].x = 0.0;
		dDischarges[DOMAIN_DIR_E].y = 0.0;
	} 
	if( lIdxY == DOMAIN_COLS - 2 ) {
		dDischarges[DOMAIN_DIR_N].x = 0.0;
		dDischarges[DOMAIN_DIR_N].y = 0.0;
	}
	if( lIdxX == 1 ) {
		dDischarges[DOMAIN_DIR_W].x = 0.0;
		dDischarges[DOMAIN_DIR_W].y = 0.0;
	}
	if( lIdxY == 1 ) {
		dDischarges[DOMAIN_DIR_S].x = 0.0;
		dDischarges[DOMAIN_DIR_S].y = 0.0;
	}

	if(ulIdx==9696 && debug){
		//for(int i=0; i<log10(pNeigDataW.x-dNeigBedElevW)-1;i++){printf(" ");}
		//printf("         %f   \n",						pNeigDataN.x-dNeigBedElevN);
		//printf("%f %f %f\n",pNeigDataW.x-dNeigBedElevW,pCellData.x-dCellBedElev,pNeigDataE.x-dNeigBedElevE);
		//for(int i=0; i<log10(pNeigDataW.x-dNeigBedElevW)-1;i++){printf(" ");}
		//printf("         %f   \n\n",						pNeigDataS.x-dNeigBedElevS);
		printf("%f %f %f %f\n", pCellStateSrc[getCellID(lIdxX,lIdxY+3)].x-dBedElevation[getCellID(lIdxX,lIdxY+3)], pCellStateSrc[getCellID(lIdxX+1,lIdxY+3)].x-dBedElevation[getCellID(lIdxX+1,lIdxY+3)] ,pCellStateSrc[getCellID(lIdxX+2,lIdxY+3)].x-dBedElevation[getCellID(lIdxX+2,lIdxY+3)], pCellStateSrc[getCellID(lIdxX+3,lIdxY+3)].x-dBedElevation[getCellID(lIdxX+3,lIdxY+3)]);
		printf("%f %f %f %f\n", pCellStateSrc[getCellID(lIdxX,lIdxY+2)].x-dBedElevation[getCellID(lIdxX,lIdxY+2)], pCellStateSrc[getCellID(lIdxX+1,lIdxY+2)].x-dBedElevation[getCellID(lIdxX+1,lIdxY+2)] ,pCellStateSrc[getCellID(lIdxX+2,lIdxY+2)].x-dBedElevation[getCellID(lIdxX+2,lIdxY+2)], pCellStateSrc[getCellID(lIdxX+3,lIdxY+2)].x-dBedElevation[getCellID(lIdxX+3,lIdxY+2)]);
		printf("%f %f %f %f\n", pCellStateSrc[getCellID(lIdxX,lIdxY+1)].x-dBedElevation[getCellID(lIdxX,lIdxY+1)], pCellStateSrc[getCellID(lIdxX+1,lIdxY+1)].x-dBedElevation[getCellID(lIdxX+1,lIdxY+1)] ,pCellStateSrc[getCellID(lIdxX+2,lIdxY+1)].x-dBedElevation[getCellID(lIdxX+2,lIdxY+1)], pCellStateSrc[getCellID(lIdxX+3,lIdxY+1)].x-dBedElevation[getCellID(lIdxX+3,lIdxY+1)]);
		printf("%f %f %f %f\n\n", pCellStateSrc[getCellID(lIdxX,lIdxY)].x-dBedElevation[getCellID(lIdxX,lIdxY  )], pCellStateSrc[getCellID(lIdxX+1,lIdxY  )].x-dBedElevation[getCellID(lIdxX+1,lIdxY)]   ,pCellStateSrc[getCellID(lIdxX+2,lIdxY)].x-dBedElevation[getCellID(lIdxX+2,lIdxY)],   pCellStateSrc[getCellID(lIdxX+3,lIdxY)].x-dBedElevation[getCellID(lIdxX+3,lIdxY)]);
		printf("dTimestep: %f N: %f E: %f S: %f W: %f\n\n",dTimestep,dDischarges[DOMAIN_DIR_N].x,dDischarges[DOMAIN_DIR_E].x,dDischarges[DOMAIN_DIR_S].x,dDischarges[DOMAIN_DIR_W].x);
	}


	dDeltaFSL	= (dDischarges[DOMAIN_DIR_E].x + dDischarges[DOMAIN_DIR_W].x + dDischarges[DOMAIN_DIR_N].x + dDischarges[DOMAIN_DIR_S].x)/(DOMAIN_DELTAX*DOMAIN_DELTAY);
	

	pCellData.z		= dDischarges[DOMAIN_DIR_W].y;
	pCellData.w		= dDischarges[DOMAIN_DIR_S].y;

	// Update the flow state
	pCellData.x		= pCellData.x + dLclTimestep * dDeltaFSL;

	// New max FSL?
	if ( pCellData.x > pCellData.y )
		pCellData.y = pCellData.x;

	// Crazy low depths?
	if ( pCellData.x - dCellBedElev < VERY_SMALL )
		pCellData.x = dCellBedElev;

	// Commit to global memory
	pCellStateDst[ ulIdx ] = pCellData;
}


cl_double2 manning_Solver(
	cl_double Timestep,
	cl_double manning,
	cl_double manning_Neig,
	cl_double opt_s_Cell,
	cl_double opt_s_Neig,
	cl_double opt_z_Cell,
	cl_double opt_z_Neig,
	bool debug
	)
	{
		cl_double2 output;

		cl_double dDischarge	= 0.0;
		
		if (opt_s_Neig-opt_z_Neig > VERY_SMALL || opt_s_Cell-opt_z_Cell > VERY_SMALL){

			cl_double flow_depth	= fmax( opt_s_Cell, opt_s_Neig ) - fmax( opt_z_Neig, opt_z_Cell );

			if (flow_depth > VERY_SMALL){

				cl_double delta_h		= opt_s_Neig - opt_s_Cell;
				cl_double abs_delta_h	= fabs(delta_h);

				if(abs_delta_h > VERY_SMALL){

					//if (abs_delta_h <= 0.005078){dDischarge = 1/(0.5*(manning+manning_Neig)) * pow(flow_depth,5.0/3.0) * delta_h / pow(DOMAIN_DELTAX * abs_delta_h,0.5) * DOMAIN_DELTAY;
					
					//}else{
						dDischarge = 1/(0.5*(manning+manning_Neig)) * pow(flow_depth,5.0/3.0) * delta_h / pow(DOMAIN_DELTAX * abs_delta_h,0.5) * DOMAIN_DELTAY;
					//}
				}

				//Froude number discharge limiter
				//if ( dDischarge > 0.0 &&
				//	 ( ( fabs( dDischarge ) / delta_h ) / sqrt( GRAVITY * flow_depth ) ) > FROUDE_LIMIT )
				//	dDischarge = flow_depth * sqrt( GRAVITY * flow_depth ) * FROUDE_LIMIT;
				//if ( dDischarge < 0.0 &&
				//	 ( ( fabs( dDischarge ) / delta_h) / sqrt( GRAVITY * flow_depth ) ) > FROUDE_LIMIT )
				//	dDischarge = 0.0 - flow_depth * sqrt( GRAVITY * flow_depth ) * FROUDE_LIMIT;
		
		
				// Alaa: Does this make better memory access here or should we put it directly after calculation?
				//if ( flow_depth < VERY_SMALL )
				//	dDischarge = 0.0;

			}
		}

		output.x = dDischarge;
		output.y = dDischarge/DOMAIN_DELTAX/DOMAIN_DELTAY;

		return output;

	}
