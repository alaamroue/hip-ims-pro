
#define FRICTION_IN_FLUX_KERNEL 1
#define QUITE_SMALL 0.000000
#define VERY_SMALL 0.000000
#define DOMAIN_DELTAX 100.000000
#define GTS_DIM2 8
#define REQD_WG_SIZE_FULL_TS __attribute__((reqd_work_group_size(8, 8, 1)))
#define REQD_WG_SIZE_LINE __attribute__((reqd_work_group_size(256, 1, 1)))
#define GTS_DIM1 8
#define TIMESTEP_DYNAMIC 1
#define TIMESTEP_WORKERS 256
#define SCHEME_OUTPUTTIME 3600000.000000
#define TIMESTEP_GROUPSIZE 256
#define SCHEME_ENDTIME 3600000.000000
#define COURANT_NUMBER 0.500000
#define DOMAIN_CELLCOUNT 10000
#define DOMAIN_COLS 100
#define DOMAIN_DELTAY 100.000000
#define DOMAIN_ROWS 100
#pragma OPENCL EXTENSION cl_khr_fp64 : enable
typedef double      cl_double;
typedef double2     cl_double2;
typedef double4     cl_double4;
typedef double8     cl_double8;
/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  DEVICE MODULE (OPENCL, C99)
 * ------------------------------------------
 *  Universal header, included in every single
 *  program compiled by this model for OpenCL.
 * ------------------------------------------
 *
 */

// To be made configurable at a later date
#define USE_FUNCTION_STUBS			1
#define USE_ALTERNATE_CONSTRUCTS	1

// Enable to use printf with AMD devices
#ifdef DEBUG_OUTPUT
#pragma		OPENCL EXTENSION cl_amd_printf   : enable
//#pragma		OPENCL EXTENSION cl_intel_printf : enable
#endif

#define		GRAVITY					9.81		// 9.80665

// Type aliases to be consistent across different platforms
typedef char	    cl_char;
typedef uchar		cl_uchar;
typedef short       cl_short;
typedef ushort		cl_ushort;
typedef int			cl_int;
typedef int2		cl_int2;
//typedef int3		cl_int3;
typedef int4		cl_int4;
typedef int8		cl_int8;
typedef uint		cl_uint;
typedef uint2		cl_uint2;
//typedef uint3		cl_uint3;
typedef uint4		cl_uint4;
typedef uint8		cl_uint8;
typedef long		cl_long;
typedef long2		cl_long2;
//typedef long3		cl_long3;
typedef long4		cl_long4;
typedef long8		cl_long8;
typedef ulong		cl_ulong;
typedef ulong2		cl_ulong2;
//typedef ulong3		cl_ulong3;
typedef ulong4		cl_ulong4;
typedef ulong8		cl_ulong8;
//typedef half		cl_half;			// Requires OpenCL extension...
typedef float       cl_float;
typedef float2      cl_float2;
//typedef float3      cl_float3;
typedef float4      cl_float4;
typedef float8      cl_float8;

/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  Header file
 *  CARTESIAN DOMAIN
 * ------------------------------------------
 *  Management functions for a Cartesian
 *  domain.
 * ------------------------------------------
 *
 */

// Note: Some compile-time constants are defined automatically by
// the model, including:
//   DOMAIN_CELLCOUNT
//   DOMAIN_ROWS
//   DOMAIN_COLS
//   DOMAIN_DELTAX
//   DOMAIN_DELTAY

// Neighbour directions
#define DOMAIN_DIR_N	0
#define DOMAIN_DIR_E	1
#define DOMAIN_DIR_S	2
#define DOMAIN_DIR_W	3

#ifdef USE_FUNCTION_STUBS

// Function definitions
cl_ulong	getNeighbourID(cl_ulong, cl_uchar);
cl_ulong	getNeighbourByIndices(cl_long, cl_long, cl_uchar);
cl_ulong	getCellID(cl_long, cl_long);
void		getCellIndices( cl_ulong, cl_long*, cl_long* );

#endif
/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  Header file
 *  FRICTION
 * ------------------------------------------
 *  Calculate the timestep using a reduction
 *  procedure and increment the total model 
 *  time.
 * ------------------------------------------
 *
 */

#ifdef USE_FUNCTION_STUBS

// Function definitions
__kernel  REQD_WG_SIZE_FULL_TS
void per_Friction ( 
	__constant	cl_double *,
	__global	cl_double4 *,
	__global	cl_double *,
	__global	cl_double *,
	__global	cl_double *  	// TEMP only for rainfall		
);

cl_double4 implicitFriction(
	cl_double4,
	cl_double,
	cl_double,
	cl_double
);

#endif/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  Header file
 *  HLLC APPROXIMATE RIEMANN SOLVER
 * ------------------------------------------
 *  Implementation of the approximate HLLC
 *  Riemann solver for the GPU.
 * ------------------------------------------
 *
 */

#ifdef USE_FUNCTION_STUBS

// Function definitions
cl_double4	riemannSolver(
	cl_uchar,
	cl_double8,
	cl_double8,
	bool
);

#endif/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  Header file
 *  CFL DYNAMIC TIMESTEP
 * ------------------------------------------
 *  Calculate the timestep using a reduction
 *  procedure and increment the total model 
 *  time.
 * ------------------------------------------
 *
 */
#define TIMESTEP_EARLY_LIMIT			0.1
#define TIMESTEP_EARLY_LIMIT_DURATION	60.0
#define TIMESTEP_START_MINIMUM			1E-10
#define TIMESTEP_START_MINIMUM_DURATION	1.0
#define TIMESTEP_MINIMUM				1E-10
#define TIMESTEP_MAXIMUM				15.0

#ifdef USE_FUNCTION_STUBS
// Function definitions
__kernel  __attribute__((reqd_work_group_size(1, 1, 1)))
void tst_Advance_Normal ( 
	__global	cl_double *,
	__global	cl_double *,
	__global	cl_double *,
	__global	cl_double *,
	__global	cl_double4 *,
	__global	cl_double *,
	__global	cl_double *,
	__global	cl_double *,
	__global	cl_uint *,
	__global	cl_uint *
);

__kernel  __attribute__((reqd_work_group_size(1, 1, 1)))
void tst_ResetCounters(
	__global	cl_double *,
	__global	cl_uint *,
	__global	cl_uint *
);

__kernel  __attribute__((reqd_work_group_size(1, 1, 1)))
void tst_UpdateTimestep ( 
	__global	cl_double *,
	__global	cl_double *,
	__global	cl_double *,
	__global	cl_double *,
	__global	cl_double *
);

__kernel  REQD_WG_SIZE_LINE
void tst_Reduce ( 
	__global	cl_double4 *,
	__global	cl_double const * restrict,
	__global	cl_double *
);

#endif
/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  Header file
 *  GODUNOV-TYPE SCHEME
 * ------------------------------------------
 *  Implementation of the 1st order accurate
 *  Godunov-type scheme for execution on the
 *  GPU.
 * ------------------------------------------
 *
 */

// Structure definitions
typedef struct sFaceStructure {
	cl_double4	pN;
	cl_double4	pE;
	cl_double4	pS;
	cl_double4	pW;
} sFaceStructure;

#ifdef USE_FUNCTION_STUBS

// Function definitions
__kernel  REQD_WG_SIZE_FULL_TS
void gts_cacheDisabled ( 
	__constant	cl_double *,
	__global	cl_double const * restrict,
	__global	cl_double4 *,
	__global	cl_double4 *,
	__global    cl_double const * restrict
);

__kernel  REQD_WG_SIZE_FULL_TS
void gts_cacheEnabled ( 
	__constant	cl_double *,
	__global	cl_double const * restrict,
	__global	cl_double4 *,
	__global	cl_double4 *,
	__global    cl_double const * restrict
);

cl_uchar reconstructInterface(
	cl_double4,
	cl_double,
	cl_double4,
	cl_double,
	cl_double8*,
	cl_double8*,
	cl_uchar
);

#endif
/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  Header file
 *  BOUNDARY CONDITIONS
 * ------------------------------------------
 *  Management functions for a domain
 *  boundaries.
 * ------------------------------------------
 *
 */

// Hydrological timestep
// This should be low to capture velocities properly, but isn't
// always necessary
// TODO: Make configurable...
#define TIMESTEP_HYDROLOGICAL			1.0

// Boundary types
#define BOUNDARY_ATMOSPHERIC			0
#define BOUNDARY_FLOWCONDITIONS			1

// Boundary operating definitions
#define BOUNDARY_DEPTH_IGNORE			0
#define BOUNDARY_DEPTH_IS_FSL			1
#define BOUNDARY_DEPTH_IS_DEPTH			2
#define BOUNDARY_DEPTH_IS_CRITICAL		3

#define BOUNDARY_DISCHARGE_IGNORE		0
#define BOUNDARY_DISCHARGE_IS_DISCHARGE	1
#define BOUNDARY_DISCHARGE_IS_VELOCITY	2
#define BOUNDARY_DISCHARGE_IS_VOLUME	3

#define BOUNDARY_UNIFORM_RAIN_INTENSITY	0
#define BOUNDARY_UNIFORM_LOSS_RATE		1

#define BOUNDARY_GRIDDED_RAIN_INTENSITY 0
#define BOUNDARY_GRIDDED_RAIN_ACCUMUL	1
#define BOUNDARY_GRIDDED_MASS_FLUX		2

#ifdef USE_FUNCTION_STUBS

typedef struct sBdyCellConfiguration
{
	cl_ulong		TimeseriesEntries;
	cl_double		TimeseriesInterval;
	cl_double		TimeseriesLength;
	cl_ulong		RelationCount;
	cl_uint			DefinitionDepth;
	cl_uint			DefinitionDischarge;
} sBdyCellConfiguration;

typedef struct sBdyGriddedConfiguration
{
	cl_double		TimeseriesInterval;
	cl_double		GridResolution;
	cl_double		GridOffsetX;
	cl_double		GridOffsetY;
	cl_ulong		TimeseriesEntries;
	cl_ulong		Definition;
	cl_ulong		GridRows;
	cl_ulong		GridCols;
} sBdyGriddedConfiguration;

typedef struct sBdyUniformConfiguration
{
	cl_uint			TimeseriesEntries;
	cl_double		TimeseriesInterval;
	cl_double		TimeseriesLength;
	cl_uint			Definition;
} sBdyUniformConfiguration;

__kernel void bdy_Cell ( 
	__constant		sBdyCellConfiguration *,
	__global		cl_ulong const * restrict,
	__global		cl_double4 const * restrict,
	__global		cl_double *,
	__global		cl_double *,
	__global		cl_double *,
	__global		cl_double4 *,
	__global		cl_double *,
	__global		cl_double *
);

__kernel void bdy_Gridded ( 
	__constant		sBdyGriddedConfiguration *,
	__global		cl_double const * restrict,
	__global		cl_double *,
	__global		cl_double *,
	__global		cl_double *,
	__global		cl_double4 *,
	__global		cl_double *,
	__global		cl_double *
);

__kernel void bdy_Uniform ( 
	__constant		sBdyUniformConfiguration *,
	__global		cl_double2 const * restrict,
	__global		cl_double *,
	__global		cl_double *,
	__global		cl_double *,
	__global		cl_double4 *,
	__global		cl_double *,
	__global		cl_double *
);

#endif/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  CARTESIAN DOMAIN
 * ------------------------------------------
 *  Management functions for a Cartesian
 *  domain.
 * ------------------------------------------
 *
 */

/*
 *  Fetch the ID for a cell using its X and Y indices
 */
cl_ulong	getCellID(cl_long lIdxX, cl_long lIdxY)
{
	cl_long	lCols = DOMAIN_COLS;
	return (lIdxY * lCols) + lIdxX;
}

/*
 *  Fetch the X and Y indices for a cell using its ID
 */
void	getCellIndices(cl_ulong ulID, cl_long* lIdxX, cl_long* lIdxY)
{
	*lIdxX = ulID % DOMAIN_COLS;
	*lIdxY = (ulID - *lIdxX) / DOMAIN_COLS;
}

/*
 *  Fetch the ID for a neighbouring cell in the domain
 */
cl_ulong	getNeighbourID(cl_ulong ulCellID, cl_uchar ucDirection)
{
	cl_long lIdxX = 0;
	cl_long lIdxY = 0;
	getCellIndices( ulCellID, &lIdxX, &lIdxY );

	switch( ucDirection )
	{
	case DOMAIN_DIR_N:
		++lIdxY;
		break;
	case DOMAIN_DIR_E:
		++lIdxX;
		break;
	case DOMAIN_DIR_S:
		--lIdxY;
		break;
	case DOMAIN_DIR_W:
		--lIdxX;
		break;
	}

	return getCellID( lIdxX, lIdxY );
}

/*
 *  Fetch the ID for a neighbouring cell in the domain
 */
cl_ulong	getNeighbourByIndices( cl_long lIdxX, cl_long lIdxY, cl_uchar ucDirection )
{
	switch( ucDirection )
	{
	case DOMAIN_DIR_N:
		++lIdxY;
		break;
	case DOMAIN_DIR_E:
		++lIdxX;
		break;
	case DOMAIN_DIR_S:
		--lIdxY;
		break;
	case DOMAIN_DIR_W:
		--lIdxX;
		break;
	}

	return getCellID( lIdxX, lIdxY );
}
/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  IMPLICIT FRICTION
 * ------------------------------------------
 *  Reduce discharge values according to 
 *  friction coefficients.
 * ------------------------------------------
 *
 */

/*
 *	Point-implicit calculation of the friction effects
 */
cl_double4 implicitFriction(
	cl_double4		pCellState,
	cl_double		dBedElevation,
	cl_double		dManningCoefficient,
	cl_double		dLclTimestep
	)
{
	__private cl_double		dDepth, dQ;

	// Calculate depth and composite discharge
	dQ = sqrt(pCellState.z * pCellState.z + pCellState.w * pCellState.w);
	dDepth = pCellState.x - dBedElevation;

	// Low discharge or low depth means don't bother
	if (dDepth < VERY_SMALL || dQ < VERY_SMALL) return pCellState;

	// Coefficient of friction, etc. See Liang (2010)
	__private cl_double		dCf = (GRAVITY * dManningCoefficient * dManningCoefficient) / (pow((cl_double)dDepth, (cl_double)(1.0 / 3.0)));
	__private cl_double		dSfx = (-dCf / (dDepth * dDepth)) * pCellState.z * dQ;
	__private cl_double		dSfy = (-dCf / (dDepth * dDepth)) * pCellState.w * dQ;
	__private cl_double		dDx = 1.0 + dLclTimestep * (dCf / (dDepth * dDepth)) * (2 * (pCellState.z * pCellState.z) + (pCellState.w * pCellState.w)) / dQ;
	__private cl_double		dDy = 1.0 + dLclTimestep * (dCf / (dDepth * dDepth)) * ((pCellState.z * pCellState.z) + 2 * (pCellState.w * pCellState.w)) / dQ;
	__private cl_double		dFx = dSfx / dDx;
	__private cl_double		dFy = dSfy / dDy;

	// Friction can only stop flow, not reverse it
	if (pCellState.z >= 0.0)
	{
		if (dFx < -pCellState.z / dLclTimestep) dFx = -pCellState.z / dLclTimestep;
	}
	else {
		if (dFx > -pCellState.z / dLclTimestep) dFx = -pCellState.z / dLclTimestep;
	}
	if (pCellState.w >= 0.0)
	{
		if (dFy < -pCellState.w / dLclTimestep) dFy = -pCellState.w / dLclTimestep;
	}
	else {
		if (dFy > -pCellState.w / dLclTimestep) dFy = -pCellState.w / dLclTimestep;
	}

	// Update and commit data
	pCellState.z = pCellState.z + dLclTimestep * dFx;
	pCellState.w = pCellState.w + dLclTimestep * dFy;

	return pCellState;
}

/*
 *  Adjust the discharge with regard to friction
 */
__kernel  REQD_WG_SIZE_FULL_TS
void per_Friction( 
		__constant cl_double *  	dTimestep,
		__global cl_double4 *  	pCellData,
		__global cl_double *  	dBedData,
		__global cl_double *  	dManningData,
		__global cl_double *  	dTime			// TODO: Remove this, only required for temp rain
	)
{
	__private cl_double		dLclTimestep	= *dTimestep;
	__private cl_long		lIdxX			= get_global_id(0);
	__private cl_long		lIdxY			= get_global_id(1);
	__private cl_ulong		ulIdx;

	__private cl_double4	pCellState;
	__private cl_double		dBedElevation;
	__private cl_double		dManningCoefficient;

	// Don't bother if we've gone beyond the domain bounds
	if ( lIdxX >= DOMAIN_COLS - 1 || lIdxY >= DOMAIN_ROWS - 1 || lIdxX == 0 || lIdxY == 0 ) 
		return;

	// Also don't bother if we've gone beyond the total simulation time
	if ( dLclTimestep <= 0.0 )
		return;

	ulIdx = getCellID(lIdxX, lIdxY);
	pCellState			= pCellData[ ulIdx ];
	dBedElevation		= dBedData[ ulIdx ];
	dManningCoefficient	= dManningData[ ulIdx ];

	if ( pCellState.x - dBedElevation < VERY_SMALL ) 
		return;

	pCellState = implicitFriction(
		pCellState,
		dBedElevation,
		dManningCoefficient,
		dLclTimestep
	);

	// TODO: Remvoe this
	// TEMPORARY ONLY
	// Introduce some rainfall to the domain at 10mm/hr
	//pCellState.x += 0.060/3600 * dLclTimestep;

	pCellData[ ulIdx ]	= pCellState;
}
/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  HLLC APPROXIMATE RIEMANN SOLVER
 * ------------------------------------------
 *  Implementation of the approximate HLLC
 *  Riemann solver for the GPU.
 * ------------------------------------------
 *
 */

/*
 *  Calculate an approximate solution to the Riemann problem
 *  at the cell interface using the HLLC approach.
 */
cl_double4 riemannSolver(
	cl_uchar	ucDirection,
	cl_double8		pLeft,
	cl_double8		pRight,
	bool		bDebug
	)
{
	uint2		uiDirectionVector;
	cl_double	FM_L, FM_R, F1_M, F2_M;
	cl_double	s_L, s_R, s_M, a_Avg, H_star, U_star, A_star;
	cl_double4	pFluxL, pFluxR, pFlux;
	cl_double2	dVel, dDis, dA;
	bool		bLeft, bRight, bMiddle_1, bMiddle_2;

#ifdef USE_ALTERNATE_CONSTRUCTS
	uiDirectionVector = ( ( ucDirection == DOMAIN_DIR_N || ucDirection == DOMAIN_DIR_S ) ? (uint2){0,1} : (uint2){1,0} );

	// Are both sides dry? Simple solution if so...
	if (pLeft.S1 < VERY_SMALL && pRight.S1 < VERY_SMALL)
	{
		pFlux = (cl_double4){
			0.0,
				uiDirectionVector.S0 * 0.5 * GRAVITY * (
				((pLeft.S0 + pRight.S0) / 2) * ((pLeft.S0 + pRight.S0) / 2) -
				pLeft.S6 * (pLeft.S0 + pRight.S0)
				),
				uiDirectionVector.S1 * 0.5 * GRAVITY * (
				((pLeft.S0 + pRight.S0) / 2) * ((pLeft.S0 + pRight.S0) / 2) -
				pLeft.S6 * (pLeft.S0 + pRight.S0)
				),
				0.0
		};

		return pFlux;
	}
#else
	uiDirectionVector = ((ucDirection == DOMAIN_DIR_N || ucDirection == DOMAIN_DIR_S) ? (uint2)(0, 1) : (uint2)(1, 0));

	// Are both sides dry? Simple solution if so...
	if (pLeft.S1 < VERY_SMALL && pRight.S1 < VERY_SMALL)
	{
		pFlux = (cl_double4)(
			0.0,
			uiDirectionVector.S0 * 0.5 * GRAVITY * (
			((pLeft.S0 + pRight.S0) / 2) * ((pLeft.S0 + pRight.S0) / 2) -
			pLeft.S6 * (pLeft.S0 + pRight.S0)
			),
			uiDirectionVector.S1 * 0.5 * GRAVITY * (
			((pLeft.S0 + pRight.S0) / 2) * ((pLeft.S0 + pRight.S0) / 2) -
			pLeft.S6 * (pLeft.S0 + pRight.S0)
			),
			0.0
			);

		return pFlux;
	}
#endif

	// Is one side dry?
	// -> Left
	pLeft.S4 = (pLeft.S1 < VERY_SMALL ? 0.0 : pLeft.S2 / pLeft.S1);
	pLeft.S5 = (pLeft.S1 < VERY_SMALL ? 0.0 : pLeft.S3 / pLeft.S1);

	// -> Right
	pRight.S4 = (pRight.S1 < VERY_SMALL ? 0.0 : pRight.S2 / pRight.S1);
	pRight.S5 = (pRight.S1 < VERY_SMALL ? 0.0 : pRight.S3 / pRight.S1);

	// Prerequisite calculations
#ifdef USE_ALTERNATE_CONSTRUCTS
	dVel    = (cl_double2){
			uiDirectionVector.S0 * pLeft.S4 + uiDirectionVector.S1 * pLeft.S5,				// Left
			uiDirectionVector.S0 * pRight.S4 + uiDirectionVector.S1 * pRight.S5				// Right
		};
	dDis = (cl_double2){
			uiDirectionVector.S0 * pLeft.S2 + uiDirectionVector.S1 * pLeft.S3,				// Left
			uiDirectionVector.S0 * pRight.S2 + uiDirectionVector.S1 * pRight.S3				// Right
		};
	dA = (cl_double2){
			sqrt(GRAVITY * pLeft.S1),														// Left
			sqrt(GRAVITY * pRight.S1)														// Right
		};
#else
	dVel    = (cl_double2)( 
				uiDirectionVector.S0 * pLeft.S4   + uiDirectionVector.S1 * pLeft.S5,		// Left
				uiDirectionVector.S0 * pRight.S4  + uiDirectionVector.S1 * pRight.S5		// Right
			);
	dDis    = (cl_double2)( 
				uiDirectionVector.S0 * pLeft.S2   + uiDirectionVector.S1 * pLeft.S3,		// Left
				uiDirectionVector.S0 * pRight.S2  + uiDirectionVector.S1 * pRight.S3		// Right
			);
	dA      = (cl_double2)( 
				sqrt( GRAVITY * pLeft.S1  ),												// Left
				sqrt( GRAVITY * pRight.S1 )													// Right
			);
#endif

	a_Avg	= ( dA.S0   + dA.S1   ) / 2;
	H_star	= ( ( a_Avg + ( dVel.S0 - dVel.S1 )/4 ) * ( a_Avg + ( dVel.S0 - dVel.S1 )/4 ) ) / GRAVITY;
	U_star	= ( dVel.S0 + dVel.S1 ) / 2 + dA.S0 - dA.S1;
	A_star	= sqrt( GRAVITY * H_star );

	// Calculate speed estimates
	if ( pLeft.S1 < VERY_SMALL )
	{
		s_L = dVel.S1 - 2 * dA.S1;
	} else {
		s_L = ( ( ( dVel.S0 - dA.S0 ) > (U_star - A_star) ) ? ( U_star - A_star ) : ( dVel.S0 - dA.S0 ) );
	}
	if ( pRight.S1 < VERY_SMALL )
	{
		s_R = dVel.S0 + 2 * dA.S0;
	} else {
		s_R = ( ( ( dVel.S1 + dA.S1 ) < ( U_star + A_star ) ) ? ( U_star + A_star ) : ( dVel.S1 + dA.S1 ) );
	}
	s_M = ( s_L * pRight.S1 * ( dVel.S1 - s_R ) - s_R * pLeft.S1 * ( dVel.S0-s_L ) ) /
			( pRight.S1 * ( dVel.S1 - s_R ) - pLeft.S1 * ( dVel.S0 - s_L ) );

	// Flux on left and right
#ifdef USE_ALTERNATE_CONSTRUCTS
	pFluxL		= (cl_double4){
						dDis.S0,
						dVel.S0 * pLeft.S2 + uiDirectionVector.S0 * 0.5 * GRAVITY * ( pLeft.S0*pLeft.S0 - 2 * pLeft.S6 * pLeft.S0 ),
						dVel.S0 * pLeft.S3 + uiDirectionVector.S1 * 0.5 * GRAVITY * ( pLeft.S0*pLeft.S0 - 2 * pLeft.S6 * pLeft.S0 ),
						0.0
					};
	pFluxR		= (cl_double4){
						dDis.S1,
						dVel.S1 * pRight.S2 + uiDirectionVector.S0 * 0.5 * GRAVITY * ( pRight.S0*pRight.S0 - 2 * pLeft.S6 * pRight.S0 ),
						dVel.S1 * pRight.S3 + uiDirectionVector.S1 * 0.5 * GRAVITY * ( pRight.S0*pRight.S0 - 2 * pLeft.S6 * pRight.S0 ),
						0.0
					};
#else
	pFluxL = (cl_double4)(
		dDis.S0,
		dVel.S0 * pLeft.S2 + uiDirectionVector.S0 * 0.5 * GRAVITY * (pLeft.S0*pLeft.S0 - 2 * pLeft.S6 * pLeft.S0),
		dVel.S0 * pLeft.S3 + uiDirectionVector.S1 * 0.5 * GRAVITY * (pLeft.S0*pLeft.S0 - 2 * pLeft.S6 * pLeft.S0),
		0.0
		);
	pFluxR = (cl_double4)(
		dDis.S1,
		dVel.S1 * pRight.S2 + uiDirectionVector.S0 * 0.5 * GRAVITY * (pRight.S0*pRight.S0 - 2 * pLeft.S6 * pRight.S0),
		dVel.S1 * pRight.S3 + uiDirectionVector.S1 * 0.5 * GRAVITY * (pRight.S0*pRight.S0 - 2 * pLeft.S6 * pRight.S0),
		0.0
		);
#endif

	// Selection of the final result
	bLeft			= s_L >= 0.0;
	bMiddle_1		= s_L <  0.0 && s_R >= 0.0 && s_M >= 0.0;
	bMiddle_2		= s_L <  0.0 && s_R >= 0.0 && !bMiddle_1;
	bRight			= !bLeft && !bMiddle_1 && !bMiddle_2;

	if ( bLeft )  
	{
		#ifdef DEBUG_OUTPUT
		if ( bDebug )
		{
			printf( "(Dir %i) Using left fluxes\n", ucDirection );
		}
		#endif
		return pFluxL;
	}
	if ( bRight ) 
	{
		#ifdef DEBUG_OUTPUT
		if ( bDebug )
		{
			printf( "(Dir %i) Using right fluxes\n", ucDirection );
		}
		#endif
		return pFluxR;
	}

	FM_L	= uiDirectionVector.S0 * pFluxL.y + uiDirectionVector.S1 * pFluxL.z;
	FM_R	= uiDirectionVector.S0 * pFluxR.y + uiDirectionVector.S1 * pFluxR.z;
	F1_M	= ( s_R * pFluxL.x - s_L * pFluxR.x + s_L * s_R * ( pRight.S0 - pLeft.S0 ) ) / ( s_R - s_L );
	F2_M	= ( s_R * FM_L     - s_L * FM_R     + s_L * s_R * ( dDis.S1   - dDis.S0  ) ) / ( s_R - s_L );

#ifdef USE_ALTERNATE_CONSTRUCTS
	if ( bMiddle_1 )
	{
		pFlux = (cl_double4){
			F1_M,
			uiDirectionVector.S0 * F2_M + uiDirectionVector.S1 * F1_M * pLeft.S4,
			uiDirectionVector.S0 * F1_M * pLeft.S5 + uiDirectionVector.S1 * F2_M,
			0.0
		};
	}

	if (bMiddle_2)
	{
		pFlux = (cl_double4){
			F1_M,
			uiDirectionVector.S0 * F2_M + uiDirectionVector.S1 * F1_M * pRight.S4,
			uiDirectionVector.S0 * F1_M * pRight.S5 + uiDirectionVector.S1 * F2_M,
			0.0
		};
	}
#else
	if ( bMiddle_1 )
	{
		pFlux = (cl_double4)(
			F1_M,
			uiDirectionVector.S0 * F2_M + uiDirectionVector.S1 * F1_M * pLeft.S4,
			uiDirectionVector.S0 * F1_M * pLeft.S5 + uiDirectionVector.S1 * F2_M,
			0.0
		);
	}

	if ( bMiddle_2 )
	{
		pFlux = (cl_double4)(
			F1_M,
			uiDirectionVector.S0 * F2_M + uiDirectionVector.S1 * F1_M * pRight.S4,
			uiDirectionVector.S0 * F1_M * pRight.S5 + uiDirectionVector.S1 * F2_M,
			0.0
		);
	}
#endif

	return pFlux;
}
/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  CFL DYNAMIC TIMESTEP
 * ------------------------------------------
 *  Calculate the timestep using a reduction
 *  procedure and increment the total model 
 *  time.
 * ------------------------------------------
 *
 */

/*
 *  Advance the total model time by the timestep specified
 */
__kernel  __attribute__((reqd_work_group_size(1, 1, 1)))
void tst_Advance_Normal( 
		__global cl_double *  	dTime,
		__global cl_double *  	dTimestep,
		__global cl_double *  	dTimeHydrological,
		__global cl_double *  	pReductionData,
		__global cl_double4 *  	pCellData,
		__global cl_double *  	dBedData,
		__global cl_double *  	dTimeSync,
		__global cl_double *  	dBatchTimesteps,
		__global cl_uint *  		uiBatchSuccessful,
		__global cl_uint *  		uiBatchSkipped
	)
{
	__private cl_double	dLclTime			 = *dTime;
	__private cl_double	dLclTimestep		 = fmax( 0.0, *dTimestep );
	__private cl_double	dLclTimeHydrological = *dTimeHydrological;
	__private cl_double	dLclSyncTime		 = *dTimeSync;
	__private cl_double dLclBatchTimesteps	 = *dBatchTimesteps;
	__private cl_uint uiLclBatchSuccessful	 = *uiBatchSuccessful;
	__private cl_uint uiLclBatchSkipped		 = *uiBatchSkipped;

	// Increment total time (only ever referenced in this kernel)
	dLclTime += dLclTimestep;
	dLclBatchTimesteps += dLclTimestep;

	if ( dLclTimestep > 0.0 )
	{
		uiLclBatchSuccessful++;
	} else {
		uiLclBatchSkipped++;
	}

	// Hydrological processes run with their own timestep which is larger
	if (dLclTimeHydrological > TIMESTEP_HYDROLOGICAL)
	{
		dLclTimeHydrological = dLclTimestep;
	} else {
		dLclTimeHydrological += dLclTimestep;
	}

	#ifdef TIMESTEP_DYNAMIC

	__private cl_double dCellSpeed, dMaxSpeed;
	__private cl_double dMinTime;

	dCellSpeed = 0.0;
	dMaxSpeed  = 0.0;
	for( unsigned int i = 0; i < TIMESTEP_WORKERS; i++ )
	{
		dCellSpeed = pReductionData[i];
		if ( dCellSpeed > dMaxSpeed ) 
			dMaxSpeed = dCellSpeed;
	}

	// Convert velocity to a time (assumes domain deltaX=deltaY here)
	// Force progression at the start of a simulation.
	dMinTime = DOMAIN_DELTAX/dMaxSpeed;
	if (dLclTime < TIMESTEP_START_MINIMUM_DURATION && dMinTime < TIMESTEP_START_MINIMUM)
		dMinTime = TIMESTEP_START_MINIMUM;

	// Multiply by the Courant number
	dLclTimestep = COURANT_NUMBER * dMinTime;

	#endif
	#ifdef TIMESTEP_FIXED

	dLclTimestep = TIMESTEP_FIXED;

	#endif

	// Don't exceed the output interval
	// but also don't stop things at the start
	// Also don't exceed the synchronisation time
	/*
	if ( fmod( dLclTime, SCHEME_OUTPUTTIME ) < 1E-7 && dLclTime > 0.5 )
	{
		dLclTimestep = 0.0;
	} else {
		if ( ( dLclTime + dLclTimestep ) > ( trunc( dLclTime / SCHEME_OUTPUTTIME ) + 1 ) * SCHEME_OUTPUTTIME )
			dLclTimestep = ( ( trunc( dLclTime / SCHEME_OUTPUTTIME ) + 1 ) * SCHEME_OUTPUTTIME ) - dLclTime;
	}
	*/

	// Impose a minimum timestep
	if (dLclTimestep > 0.0 && dLclTimestep < TIMESTEP_MINIMUM)
		dLclTimestep = TIMESTEP_MINIMUM;

	// Don't exceed the sync time
	// A negative timestep suspends simulation but allows the value to be used
	// back on the host.
	if ( ( dLclTime + dLclTimestep ) >= dLclSyncTime )
	{
		if ( dLclSyncTime - dLclTime > VERY_SMALL )
			dLclTimestep = dLclSyncTime - dLclTime;
		if ( dLclSyncTime - dLclTime <= VERY_SMALL )
			dLclTimestep = -dLclTimestep;
	}

	// Control the timestep initially to ensure it's not silly, because
	// boundary conditions may only just be kicking in (i.e. dry domain)
	if (dLclTime < TIMESTEP_EARLY_LIMIT_DURATION && dLclTimestep > TIMESTEP_EARLY_LIMIT)
		dLclTimestep = TIMESTEP_EARLY_LIMIT;

	// Don't exceed the total simulation time
	if ( ( dLclTime + dLclTimestep ) > SCHEME_ENDTIME )
		dLclTimestep = SCHEME_ENDTIME - dLclTime;

	// A sensible maximum timestep
	if (dLclTimestep > TIMESTEP_MAXIMUM)
		dLclTimestep = TIMESTEP_MAXIMUM;

	// Commit to global memory
	*dTime			   = dLclTime;
	*dTimestep		   = dLclTimestep;
	*dTimeHydrological = dLclTimeHydrological;
	*dBatchTimesteps   = dLclBatchTimesteps;
	*uiBatchSuccessful = uiLclBatchSuccessful;
	*uiBatchSkipped    = uiLclBatchSkipped;
}

/*
 *  Advance the total model time by the timestep specified
 */
__kernel  __attribute__((reqd_work_group_size(1, 1, 1)))
void tst_ResetCounters ( 
		__global cl_double *  	dBatchTimesteps,
		__global cl_uint *  	uiBatchSuccessful,
		__global cl_uint *  	uiBatchSkipped
	)
{
	*uiBatchSuccessful = 0;
	*uiBatchSkipped = 0;
	*dBatchTimesteps = 0.0;
}

/*
 *  Reduce the timestep by calculating for each workgroup
 */
__kernel  REQD_WG_SIZE_LINE
void tst_Reduce( 
		__global cl_double4 *  			pCellData,
		__global cl_double const * restrict	dBedData,
		__global cl_double *  			pReductionData
	)
{
	__local cl_double pScratchData[ TIMESTEP_GROUPSIZE ];

	// Get global ID for cell
	cl_uint		uiLocalID		= get_local_id(0);
	cl_uint		uiLocalSize		= get_local_size(0);
	
	cl_ulong	ulCellID		= get_global_id(0);
	cl_double4	pCellState;
	cl_double	dBedElevation;
	cl_double	dCellSpeed, dDepth, dVelX, dVelY;
	cl_double	dMaxSpeed		= 0.0;

	while ( ulCellID < DOMAIN_CELLCOUNT )
	{
		// Calculate the velocity...
		pCellState		= pCellData[ ulCellID ];
		dBedElevation	= dBedData[ ulCellID ];
		
		dDepth = pCellState.x - dBedElevation;
		
		if ( dDepth > QUITE_SMALL && pCellState.y > -9999.0 )
		{
			#ifndef TIMESTEP_SIMPLIFIED

			dVelX = pCellState.z / dDepth;
			dVelY = pCellState.w / dDepth;
			if ( dVelX < 0.0 ) dVelX = -dVelX;
			if ( dVelY < 0.0 ) dVelY = -dVelY;

			dVelX += sqrt( GRAVITY * dDepth );
			dVelY += sqrt( GRAVITY * dDepth );

			#else

			dVelX = sqrt( GRAVITY * dDepth );
			dVelY = sqrt( GRAVITY * dDepth );

			#endif
			dCellSpeed = ( dVelX  < dVelY ) ? dVelY : dVelX;

		} else {
			dCellSpeed = 0.0;
		}

		// Is this velocity higher, therefore a greater time constraint?
		if ( dCellSpeed > dMaxSpeed ) 
			dMaxSpeed = dCellSpeed;

		// Move on to the next cell
		ulCellID += get_global_size(0);
	}

	// Commit to local memory
	pScratchData[ uiLocalID ] = dMaxSpeed;

	// No progression until scratch memory is fully populated
	barrier(CLK_LOCAL_MEM_FENCE);

	// 2nd stage of the reduction process
	// Funnelling style operation from the center
	for( int iOffset = uiLocalSize / 2;
			 iOffset > 0;
			 iOffset = iOffset / 2 )
	{
		if ( uiLocalID < iOffset )
		{
			cl_double	dComparison   = pScratchData[ uiLocalID + iOffset ];
			cl_double	dMine		  = pScratchData[ uiLocalID ];
			pScratchData[ uiLocalID ] = ( dMine < dComparison ) ? dComparison: dMine;
		} 
		barrier(CLK_LOCAL_MEM_FENCE);
	}

	// Only one workgroup to update the time
	if ( uiLocalID == 0 )
		pReductionData[ get_group_id(0) ] = pScratchData[ 0 ];
}

/*
 *  Update the timestep after a synchronisation or rollback
 *  Reduction will have been carried out again first.
 */
__kernel  __attribute__((reqd_work_group_size(1, 1, 1)))
void tst_UpdateTimestep( 
		__global cl_double *  	dTime,
		__global cl_double *  	dTimestep,
		__global cl_double *  	pReductionData,
		__global cl_double *  	dTimeSync,
		__global cl_double *  	dBatchTimesteps
	)
{
	__private cl_double	dLclTime			 = *dTime;
	__private cl_double	dLclOriginalTimestep = fabs(*dTimestep);
	__private cl_double	dLclSyncTime		 = *dTimeSync;
	__private cl_double dLclBatchTimesteps	 = *dBatchTimesteps;
	__private cl_double dLclTimestep;

	#ifdef TIMESTEP_DYNAMIC

	__private cl_double dCellSpeed, dMaxSpeed;
	__private cl_double dMinTime;

	dCellSpeed = 0.0;
	dMaxSpeed  = 0.0;
	for( unsigned int i = 0; i < TIMESTEP_WORKERS; i++ )
	{
		dCellSpeed = pReductionData[i];
		if ( dCellSpeed > dMaxSpeed ) 
			dMaxSpeed = dCellSpeed;
	}

	// Convert velocity to a time (assumes domain deltaX=deltaY here)
	// Force progression at the start of a simulation.
	dMinTime = DOMAIN_DELTAX/dMaxSpeed;
	
	if (dLclTime < TIMESTEP_START_MINIMUM_DURATION && dMinTime < TIMESTEP_START_MINIMUM)
		dMinTime = TIMESTEP_START_MINIMUM;

	// Multiply by the Courant number
	dLclTimestep = COURANT_NUMBER * dMinTime;

	#endif

	// We only adjust the timestep if it's SMALLER than our original
	// which already accounted for sync points etc.
	// TODO: Force time advancing if necessary instead of calling this...
	dLclTimestep = fmin(dLclTimestep, dLclOriginalTimestep);
	dLclBatchTimesteps  = dLclBatchTimesteps - dLclOriginalTimestep + dLclTimestep;

	// Don't exceed the early limit
	if (dLclTime < TIMESTEP_EARLY_LIMIT_DURATION && dLclTimestep > TIMESTEP_EARLY_LIMIT)
		dLclTimestep = TIMESTEP_EARLY_LIMIT;
	
	// Don't exceed the sync time
	if ((dLclTime + dLclTimestep) >= dLclSyncTime)
		dLclTimestep = fmax((cl_double)0.0, dLclSyncTime - dLclTime);

	// A sensible maximum timestep
	if (dLclTimestep > TIMESTEP_MAXIMUM)
		dLclTimestep = TIMESTEP_MAXIMUM;

	// Commit to global memory
	*dTimestep		   = dLclTimestep;
	*dBatchTimesteps   = dLclBatchTimesteps;
}
/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  GODUNOV-TYPE SCHEME
 * ------------------------------------------
 *  Implementation of the 1st order accurate
 *  Godunov-type scheme
 * ------------------------------------------
 *
 */
 
//#define DEBUG_OUTPUT
//#define DEBUG_CELLX 2
//#define DEBUG_CELLY 2

/*
 *  Reconstruct the cell data in a non-negative way (depth positivity preserving)
 */
cl_uchar reconstructInterface(
	cl_double4		pStateLeft,						// Left current state		Z, Zmax, Qx, Qy
	cl_double		dBedLeft,						// Left bed elevation
	cl_double4		pStateRight,					// Right current state
	cl_double		dBedRight,						// Right bed elevation
	cl_double8*		pOutputLeft,					// Output data for LHS of Riemann
	cl_double8*		pOutputRight,					// Output data for RHS of Riemann
	cl_uchar		ucDirection						// Direction under consideration
	)
{
	cl_uchar		ucStop = 0;
	cl_double8		pReconstructionLeft, pReconstructionRight;
	cl_double		dDepthL = pStateLeft.x - dBedLeft;
	cl_double		dDepthR = pStateRight.x - dBedRight;

	// Initial values before reconstruction
#ifdef USE_ALTERNATE_CONSTRUCTS
	pReconstructionLeft = (cl_double8)
		{pStateLeft.S0,																		// Z	S0
		dDepthL,																			// H	S1
		pStateLeft.S2,																		// Qx	S2
		pStateLeft.S3,																		// Qy	S3
		(dDepthL < VERY_SMALL ? 0.0 : pStateLeft.S2 / dDepthL),							// U	S4
		(dDepthL < VERY_SMALL ? 0.0 : pStateLeft.S3 / dDepthL),							// V	S5
		dBedLeft,																			// Zb	S6
		0.0};																				//		S7
	pReconstructionRight = (cl_double8)
		{pStateRight.S0,																	// Z	S0
		dDepthR,																			// H	S1
		pStateRight.S2,																	// Qx	S2
		pStateRight.S3,																	// Qy	S3
		(dDepthR < VERY_SMALL ? 0.0 : pStateRight.S2 / dDepthR),							// U	S4
		(dDepthR < VERY_SMALL ? 0.0 : pStateRight.S3 / dDepthR),							// V	S5
		dBedRight,																			// Zb	S6
		0.0};																				//		S7
#else
	pReconstructionLeft = (cl_double8)
		(pStateLeft.S0,																		// Z	S0
		dDepthL,																			// H	S1
		pStateLeft.S2,																		// Qx	S2
		pStateLeft.S3,																		// Qy	S3
		(dDepthL < VERY_SMALL ? 0.0 : pStateLeft.S2 / dDepthL),							// U	S4
		(dDepthL < VERY_SMALL ? 0.0 : pStateLeft.S3 / dDepthL),							// V	S5
		dBedLeft,																			// Zb	S6
		0.0);																				//		S7
	pReconstructionRight = (cl_double8)
		(pStateRight.S0,																	// Z	S0
		dDepthR,																			// H	S1
		pStateRight.S2,																	// Qx	S2
		pStateRight.S3,																	// Qy	S3
		(dDepthR < VERY_SMALL ? 0.0 : pStateRight.S2 / dDepthR),							// U	S4
		(dDepthR < VERY_SMALL ? 0.0 : pStateRight.S3 / dDepthR),							// V	S5
		dBedRight,																			// Zb	S6
		0.0);																				//		S7
#endif

	// Maximum bed elevation and vertical shift factor
	cl_double	dBedMaximum = (pReconstructionLeft.S6 > pReconstructionRight.S6 ? pReconstructionLeft.S6 : pReconstructionRight.S6);
	cl_double	dShiftV = dBedMaximum - (ucDirection < DOMAIN_DIR_S ? pStateLeft : pStateRight).S0;
	if (dShiftV < 0.0) dShiftV = 0.0;

	// Adjustment of depths and dependent elements
	pReconstructionLeft.S1 = (pStateLeft.S0 - dBedMaximum > 0.0 ? (pStateLeft.S0 - dBedMaximum) : 0.0);
	pReconstructionLeft.S0 = pReconstructionLeft.S1 + dBedMaximum;
	pReconstructionLeft.S2 = pReconstructionLeft.S1 * pReconstructionLeft.S4;
	pReconstructionLeft.S3 = pReconstructionLeft.S1 * pReconstructionLeft.S5;

	pReconstructionRight.S1 = (pStateRight.S0 - dBedMaximum > 0.0 ? (pStateRight.S0 - dBedMaximum) : 0.0);
	pReconstructionRight.S0 = pReconstructionRight.S1 + dBedMaximum;
	pReconstructionRight.S2 = pReconstructionRight.S1 * pReconstructionRight.S4;
	pReconstructionRight.S3 = pReconstructionRight.S1 * pReconstructionRight.S5;

	// Prevent draining from a dry cell
	// and the stopping conditions
	switch (ucDirection)
	{
	case DOMAIN_DIR_N:

		// NOTE: Do NOT include zero velocity in the check. Velocity must be non-negative for stopping conditions
		//		 to be required.
		if (pReconstructionLeft.S1 <= VERY_SMALL && pStateLeft.w > 0.0) { ucStop++; }
		if (pReconstructionRight.S1 <= VERY_SMALL && pReconstructionLeft.S5 < 0.0)  { ucStop++; pReconstructionLeft.S5 = 0.0; }
		if (pReconstructionLeft.S1 <= VERY_SMALL && pReconstructionRight.S5 > 0.0) { ucStop++; pReconstructionRight.S5 = 0.0; }

		break;
	case DOMAIN_DIR_S:

		if (pReconstructionRight.S1 <= VERY_SMALL && pStateRight.w < 0.0) { ucStop++; }
		if (pReconstructionRight.S1 <= VERY_SMALL && pReconstructionLeft.S5 < 0.0)  { ucStop++; pReconstructionLeft.S5 = 0.0; }
		if (pReconstructionLeft.S1 <= VERY_SMALL  && pReconstructionRight.S5 > 0.0) { ucStop++; pReconstructionRight.S5 = 0.0; }

		break;
	case DOMAIN_DIR_E:

		if (pReconstructionLeft.S1 <= VERY_SMALL  && pStateLeft.z > 0.0) { ucStop++; }
		if (pReconstructionRight.S1 <= VERY_SMALL && pReconstructionLeft.S4 < 0.0)  { ucStop++; pReconstructionLeft.S4 = 0.0; }
		if (pReconstructionLeft.S1 <= VERY_SMALL  && pReconstructionRight.S4 > 0.0) { ucStop++; pReconstructionRight.S4 = 0.0; }

		break;
	case DOMAIN_DIR_W:

		if (pReconstructionRight.S1 <= VERY_SMALL && pStateRight.z < 0.0) { ucStop++; }
		if (pReconstructionRight.S1 <= VERY_SMALL && pReconstructionLeft.S4 < 0.0)  { ucStop++; pReconstructionLeft.S4 = 0.0; }
		if (pReconstructionLeft.S1 <= VERY_SMALL  && pReconstructionRight.S4 > 0.0) { ucStop++; pReconstructionRight.S4 = 0.0; }

		break;
	}

	// Local modification of the bed level (and consequently, FSL to maintain depth)
	pReconstructionLeft.S6 = dBedMaximum - dShiftV;
	pReconstructionRight.S6 = dBedMaximum - dShiftV;
	pReconstructionLeft.S0 -= dShiftV;
	pReconstructionRight.S0 -= dShiftV;

	// Stopping conditions
	/*/
	if (   pReconstructionLeft.S1 < VERY_SMALL &&
	( ( ucDirection == DOMAIN_DIR_N && pStateLeft.w > 0.0 ) ||
	( ucDirection == DOMAIN_DIR_E && pStateLeft.z > 0.0 ) ) )
	ucStop++;
	if (   pReconstructionRight.S1 < VERY_SMALL &&
	( ( ucDirection == DOMAIN_DIR_S && pStateRight.w < 0.0 ) ||
	( ucDirection == DOMAIN_DIR_W && pStateRight.z < 0.0 ) ) )
	ucStop++;
	*/

	// Output vector: Z, H, Qx, Qy, U, V, Zb
	*pOutputLeft = pReconstructionLeft;
	*pOutputRight = pReconstructionRight;

	// Stop flow?
	return ucStop;
}

/*
 *  Calculate everything without using LDS caching
 */
__kernel REQD_WG_SIZE_FULL_TS
void gts_cacheDisabled ( 
			__constant	cl_double *  				dTimestep,						// Timestep
			__global	cl_double const * restrict	dBedElevation,					// Bed elevation
			__global	cl_double4 *  			pCellStateSrc,					// Current cell state data
			__global	cl_double4 *  			pCellStateDst,					// Current cell state data
			__global	cl_double const * restrict	dManning						// Manning values
		)
{


	// Identify the cell we're reconstructing (no overlap)
	__private cl_long					lIdxX			= get_global_id(0);
	__private cl_long					lIdxY			= get_global_id(1);
	__private cl_ulong					ulIdx, ulIdxNeig;
	__private cl_uchar					ucDirection;
	
	ulIdx = getCellID(lIdxX, lIdxY);
	if (lIdxY != 0){
	//printf("lIdxY    : %ld \n",lIdxX*10000+lIdxY);
	}

	// Don't bother if we've gone beyond the domain bounds
	if ( lIdxX >= DOMAIN_COLS - 1 || 
		 lIdxY >= DOMAIN_ROWS - 1 || 
		 lIdxX <= 0 || 
		 lIdxY <= 0 )
		 //printf("Went Beyoooond {%i, %i} {%ld,%ld}\n",DOMAIN_COLS,DOMAIN_ROWS,lIdxX,lIdxY);
		return;

	__private cl_double		dLclTimestep	= *dTimestep;
	__private cl_double		dManningCoef;
	__private cl_double		dCellBedElev,dNeigBedElevN,dNeigBedElevE,dNeigBedElevS,dNeigBedElevW;
	__private cl_double4	pCellData,pNeigDataN,pNeigDataE,pNeigDataS,pNeigDataW;					// Z, Zmax, Qx, Qy
	__private cl_double4	pSourceTerms,		dDeltaValues;										// Z, Qx, Qy
	__private cl_double4	pFlux[4];																// Z, Qx, Qy
	__private cl_double8	pLeft,				pRight;												// Z, H, Qx, Qy, U, V, Zb
	__private cl_uchar		ucStop			= 0;
	__private cl_uchar		ucDryCount		= 0;
	

	// Also don't bother if we've gone beyond the total simulation time
	if (dLclTimestep <= 0.0)
	{
		// TODO: Is there a way of avoiding this?!
		pCellStateDst[ulIdx] = pCellStateSrc[ulIdx];
		return;
	}

	// Load cell data
	dCellBedElev		= dBedElevation[ ulIdx ];
	pCellData			= pCellStateSrc[ ulIdx ];
	dManningCoef		= dManning[ ulIdx ];

	// Cell disabled?
	if ( pCellData.y <= -9999.0 || pCellData.x == -9999.0 )
	{
		pCellStateDst[ ulIdx ] = pCellData;
		return;
	}

	ucDirection = DOMAIN_DIR_W;
	ulIdxNeig = getNeighbourByIndices(lIdxX, lIdxY, ucDirection);
	dNeigBedElevW	= dBedElevation [ ulIdxNeig ];
	pNeigDataW		= pCellStateSrc	[ ulIdxNeig ];
	ucDirection = DOMAIN_DIR_S;
	ulIdxNeig = getNeighbourByIndices(lIdxX, lIdxY, ucDirection);
	dNeigBedElevS	= dBedElevation [ ulIdxNeig ];
	pNeigDataS		= pCellStateSrc	[ ulIdxNeig ];
	ucDirection = DOMAIN_DIR_N;
	ulIdxNeig = getNeighbourByIndices(lIdxX, lIdxY, ucDirection);
	dNeigBedElevN	= dBedElevation [ ulIdxNeig ];
	pNeigDataN		= pCellStateSrc	[ ulIdxNeig ];
	ucDirection = DOMAIN_DIR_E;
	ulIdxNeig = getNeighbourByIndices(lIdxX, lIdxY, ucDirection);
	dNeigBedElevE	= dBedElevation [ ulIdxNeig ];
	pNeigDataE		= pCellStateSrc	[ ulIdxNeig ];

	#ifdef DEBUG_OUTPUT
	if ( lIdxX == DEBUG_CELLX && lIdxY == DEBUG_CELLY )
	{	
		//printf( "\n");
		//printf( "    ulIdx:  { %f )\n", ulIdx);
		//printf( "    ulIdxNeig:  { %f )\n", ulIdxNeig);
		//printf( "    dNeigBedElevW:  { %f )\n", dNeigBedElevW);
		//printf( "    pNeigDataW:  { %f )\n", pNeigDataW);

		//printf( "DOMAIN_CELLCOUNT:  { %f )\n", DOMAIN_CELLCOUNT);
		//printf( "DOMAIN_ROWS:  { %f )\n", DOMAIN_ROWS);
		//printf( "DOMAIN_COLS:  { %f )\n", DOMAIN_COLS);

		//printf( "GTS_DIM1:  { %f )\n", GTS_DIM1);
		//printf( "GTS_DIM2:  { %f )\n", GTS_DIM2);
		//printf( "get_group_id:  { %f )\n", get_group_id(0));


		// Print the value of dManning for the current work-item
	    //printf("\nGlobalId: {%i,%i} \n", get_global_id(0),get_global_id(1));
		//printf("dTimestep    :  %lf\n", dTimestep[gid]);
		//printf("dBedElevation    :  %lf\n", dBedElevation[gid]);
		//printf("dManning     :  %lf \n",dManning[gid]);
		//printf("ulIdxNeig     :  %lld \n" , ulIdxNeig);

		//printf("pCellStateSrc = (%lf, %lf, %lf, %lf)\n", (pCellStateSrc)[ulIdxNeig].x, (pCellStateSrc)[ulIdxNeig].y, (pCellStateSrc)[ulIdxNeig].z, (pCellStateSrc)[ulIdxNeig]);
		//printf("pCellStateDst = (%lf, %lf, %lf, %lf)\n", (pCellStateDst)[ulIdxNeig], (pCellStateDst)[ulIdxNeig], (pCellStateDst)[ulIdxNeig], (pCellStateDst)[ulIdxNeig]);

		//printf( "Current data:  { %f, %f, %f, %f )\n", pCellData.x, pCellData.y, pCellData.z, pCellData.w );
		//printf( "Neighbour N:   { %f, %f, %f, %f )\n", pNeigDataN.x, dNeigBedElevN, pNeigDataN.z, pNeigDataN.w );
		//printf( "Neighbour E:   { %f, %f, %f, %f )\n", pNeigDataE.x, dNeigBedElevE, pNeigDataE.z, pNeigDataE.w );
		//printf( "Neighbour S:   { %f, %f, %f, %f )\n", pNeigDataS.x, dNeigBedElevS, pNeigDataS.z, pNeigDataS.w );
		//printf( "Neighbour W:   { %f, %f, %f, %f )\n", pNeigDataW.x, dNeigBedElevW, pNeigDataW.z, pNeigDataW.w );

	}
	#endif

	if ( pCellData.x  - dCellBedElev  < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataN.x - dNeigBedElevN < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataE.x - dNeigBedElevE < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataS.x - dNeigBedElevS < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataW.x - dNeigBedElevW < VERY_SMALL ) ucDryCount++;

	// All neighbours are dry? Don't bother calculating
	if ( ucDryCount >= 5 ) return;

	// Reconstruct interfaces
	// -> North
	ucStop += reconstructInterface(
		pCellData,							// Left cell data
		dCellBedElev,						// Left bed elevation
		pNeigDataN,							// Right cell data
		dNeigBedElevN,						// Right bed elevation
		&pLeft,								// Output for left
		&pRight,							// Output for right
		DOMAIN_DIR_N
	);
	pNeigDataN.x  = pRight.S0;
	dNeigBedElevN = pRight.S6;
	#ifdef DEBUG_OUTPUT
	if ( lIdxX == DEBUG_CELLX && lIdxY == DEBUG_CELLY )
	{
		//printf( "Reconstruct NL:{ %f, %f, %f, %f )\n", pLeft.S0, pLeft.S6, pLeft.S2, pLeft.S3 );
		//printf( "Reconstruct NR:{ %f, %f, %f, %f )\n", pRight.S0, pRight.S6, pRight.S2, pRight.S3 );
	}
	#endif
	pFlux[DOMAIN_DIR_N] = riemannSolver( DOMAIN_DIR_N, pLeft, pRight, false );

	// -> South
	ucStop += reconstructInterface(
		pNeigDataS,							// Left cell data
		dNeigBedElevS,						// Left bed elevation
		pCellData,							// Right cell data
		dCellBedElev,						// Right bed elevation
		&pLeft,								// Output for left
		&pRight,							// Output for right
		DOMAIN_DIR_S
	);
	pNeigDataS.x  = pLeft.S0;
	dNeigBedElevS = pLeft.S6;
	pFlux[DOMAIN_DIR_S] = riemannSolver( DOMAIN_DIR_S, pLeft, pRight, false );

	// -> East
	ucStop += reconstructInterface(
		pCellData,							// Left cell data
		dCellBedElev,						// Left bed elevation
		pNeigDataE,							// Right cell data
		dNeigBedElevE,						// Right bed elevation
		&pLeft,								// Output for left
		&pRight,							// Output for right
		DOMAIN_DIR_E
	);
	pNeigDataE.x  = pRight.S0;
	dNeigBedElevE = pRight.S6;
	pFlux[DOMAIN_DIR_E] = riemannSolver( DOMAIN_DIR_E, pLeft, pRight, false );

	// -> West
	ucStop += reconstructInterface(
		pNeigDataW,							// Left cell data
		dNeigBedElevW,						// Left bed elevation
		pCellData,							// Right cell data
		dCellBedElev,						// Right bed elevation
		&pLeft,								// Output for left
		&pRight,							// Output for right
		DOMAIN_DIR_W
	);
	pNeigDataW.x  = pLeft.S0;
	dNeigBedElevW = pLeft.S6;
	pFlux[DOMAIN_DIR_W] = riemannSolver( DOMAIN_DIR_W, pLeft, pRight, false );

	// Source term vector
	// TODO: Somehow get these sorted too...
	pSourceTerms.x = 0.0;
	pSourceTerms.y = -1 * GRAVITY * ( ( pNeigDataE.x + pNeigDataW.x ) / 2 ) * ( ( dNeigBedElevE - dNeigBedElevW ) / DOMAIN_DELTAX );
	pSourceTerms.z = -1 * GRAVITY * ( ( pNeigDataN.x + pNeigDataS.x ) / 2 ) * ( ( dNeigBedElevN - dNeigBedElevS ) / DOMAIN_DELTAY );

	// Calculation of change values per timestep and spatial dimension
	dDeltaValues.x	= ( pFlux[1].x  - pFlux[3].x  )/DOMAIN_DELTAX + 
					  ( pFlux[0].x  - pFlux[2].x  )/DOMAIN_DELTAY - 
					  pSourceTerms.x;
	dDeltaValues.z	= ( pFlux[1].y - pFlux[3].y )/DOMAIN_DELTAX + 
					  ( pFlux[0].y - pFlux[2].y )/DOMAIN_DELTAY - 
					  pSourceTerms.y;
	dDeltaValues.w	= ( pFlux[1].z - pFlux[3].z )/DOMAIN_DELTAX + 
					  ( pFlux[0].z - pFlux[2].z )/DOMAIN_DELTAY - 
					  pSourceTerms.z;

	// Round delta values to zero if small
	// TODO: Explore whether this can be rewritten as some form of clamp operation?
	if ( ( dDeltaValues.x > 0.0 && dDeltaValues.x <  VERY_SMALL ) ||
		 ( dDeltaValues.x < 0.0 && dDeltaValues.x > -VERY_SMALL ) ) 
		 dDeltaValues.x = 0.0;
	if ( ( dDeltaValues.z > 0.0 && dDeltaValues.z <  VERY_SMALL ) ||
		 ( dDeltaValues.z < 0.0 && dDeltaValues.z > -VERY_SMALL ) ) 
		 dDeltaValues.z = 0.0;
	if ( ( dDeltaValues.w > 0.0 && dDeltaValues.w <  VERY_SMALL ) ||
		 ( dDeltaValues.w < 0.0 && dDeltaValues.w > -VERY_SMALL ) ) 
		 dDeltaValues.w = 0.0;

	// Stopping conditions
	if ( ucStop > 0 )
	{
		pCellData.z = 0.0;
		pCellData.w = 0.0;
	}

	// Update the flow state
	pCellData.x		= pCellData.x	- dLclTimestep * dDeltaValues.x;
	pCellData.z		= pCellData.z	- dLclTimestep * dDeltaValues.z;
	pCellData.w		= pCellData.w	- dLclTimestep * dDeltaValues.w;

	#ifdef FRICTION_ENABLED
	#ifdef FRICTION_IN_FLUX_KERNEL
	// Calculate the friction effects
	pCellData = implicitFriction(
		pCellData,
		dCellBedElev,
		dManningCoef,
		dLclTimestep
	);
	#endif
	#endif

	// New max FSL?
	if ( pCellData.x > pCellData.y && pCellData.y > -9990.0 )
		pCellData.y = pCellData.x;

	// Crazy low depths?
	if ( pCellData.x - dCellBedElev < VERY_SMALL )
		pCellData.x = dCellBedElev;

	// Commit to global memory
	pCellStateDst[ ulIdx ] = pCellData;
}
































/*
 *  Calculate everything by also using LDS caching
 */
__kernel REQD_WG_SIZE_FULL_TS
void gts_cacheEnabled ( 
			__constant	cl_double *  				dTimestep,						// Timestep
			__global	cl_double const * restrict	dBedElevation,					// Bed elevation
			__global	cl_double4 *  			pCellStateSrc,					// Current cell state data
			__global	cl_double4 *  			pCellStateDst,					// Current cell state data
			__global	cl_double const * restrict	dManning						// Manning values
		)
{
	__local   cl_double4				lpCellState[ GTS_DIM1 ][ GTS_DIM2 ];			// Current cell state data (cache)

	// Identify the cell we're reconstructing (no overlap)
	__private cl_double					dLclTimestep;
	__private cl_long					lIdxX			= get_global_id(0) - get_group_id(0) * 2;
	__private cl_long					lIdxY			= get_global_id(1) - get_group_id(1) * 2;
	__private cl_long					lLocalX			= get_local_id(0);
	__private cl_long					lLocalY			= get_local_id(1);
	__private cl_ulong					lLocalSizeX		= get_local_size(0);
	__private cl_ulong					lLocalSizeY		= get_local_size(1);
	__private cl_double4				pCellData;
	__private cl_double					dManningCoef;
	__private cl_double					dCellBedElev;
	__private cl_ulong					ulIdx;
	__private cl_uchar					ucDirection;

	if ( lIdxX > DOMAIN_COLS - 1 || 
		 lIdxY > DOMAIN_ROWS - 1 || 
		 lIdxX < 0 || 
		 lIdxY < 0 )
	{
		// Ideally we'd just exit the function here, but then we wont reach the barrier
		lIdxX = max((long)0,min((long)(DOMAIN_COLS - 1),lIdxX));
		lIdxY = max((long)0,min((long)(DOMAIN_ROWS - 1),lIdxY));
	}

	ulIdx = getCellID(lIdxX, lIdxY);

	// The max FSL is substituted with the bed elevation, thereby reducing LDS consumption
	dLclTimestep							= *dTimestep;
	pCellData								= pCellStateSrc[ ulIdx ];
	dCellBedElev							= dBedElevation[ ulIdx ];
	dManningCoef							= dManning[ ulIdx ];
	lpCellState[ lLocalX ][ lLocalY ]		= pCellData;
	lpCellState[ lLocalX ][ lLocalY ].y		= dCellBedElev;

	#ifdef DEBUG_OUTPUT
	if ( lIdxX == DEBUG_CELLX && lIdxY == DEBUG_CELLY )
	{
		printf( "Work-item indices: { %u, %u )\n", get_global_id(0), get_global_id(1) );
		printf( "Cell index X:      { %u )\n", lIdxX );
		printf( "Cell index Y:      { %u )\n", lIdxY );
		printf( "WG index X:        { %u )\n", lLocalX );
		printf( "WG index Y:        { %u )\n", lLocalY );
		printf( "Linearised index:  { %u )\n", ulIdx );
		printf( "Local mem commit:  { %f, %f, %f, %f )\n", pCellData.x, dCellBedElev, pCellData.z, pCellData.w );
	}
	#endif

	barrier( CLK_LOCAL_MEM_FENCE );

	// Cell disabled?
	if ( pCellData.y <= -9999.0 || pCellData.x == -9999.0 )
	{
		pCellStateDst[ ulIdx ] = pCellData;
		return;
	}

	// Don't bother if we've gone beyond the domain bounds
	if ( lIdxX >= DOMAIN_COLS - 1 || 
		 lIdxY >= DOMAIN_ROWS - 1 || 
		 lIdxX <= 0 || 
		 lIdxY <= 0 ||
		 lLocalX >= lLocalSizeX - 1 ||
		 lLocalY >= lLocalSizeY - 1 ||
		 lLocalX <= 0 ||
		 lLocalY <= 0 ) 
		return;

	__private cl_double		dNeigBedElevN,dNeigBedElevE,dNeigBedElevS,dNeigBedElevW;
	__private cl_double4	pNeigDataN,pNeigDataE,pNeigDataS,pNeigDataW;							// Z, Zb, Qx, Qy
	__private cl_double4	pSourceTerms, dDeltaValues;												// Z, Qx, Qy
	__private cl_double4	pFlux[4];																// Z, Qx, Qy
	__private cl_double8	pLeft,				pRight;												// Z, H, Qx, Qy, U, V, Zb
	__private cl_uchar		ucStop			= 0;
	__private cl_uchar		ucDryCount		= 0;
	

	// Also don't bother if we've gone beyond the total simulation time
	if ( dLclTimestep <= 0.0 )
		return;

	pNeigDataW		= lpCellState[ lLocalX - 1 ][ lLocalY ];
	pNeigDataS		= lpCellState[ lLocalX ][ lLocalY - 1 ];
	pNeigDataE		= lpCellState[ lLocalX + 1 ][ lLocalY ];
	pNeigDataN		= lpCellState[ lLocalX ][ lLocalY + 1 ];
	dNeigBedElevW	= pNeigDataW.y;
	dNeigBedElevS	= pNeigDataS.y;
	dNeigBedElevE	= pNeigDataE.y;
	dNeigBedElevN	= pNeigDataN.y;

	#ifdef DEBUG_OUTPUT
	if ( lIdxX == DEBUG_CELLX && lIdxY == DEBUG_CELLY )
	{
		printf( "Current data:  { %f, %f, %f, %f )\n", pCellData.x, pCellData.y, pCellData.z, pCellData.w );
		printf( "Neighbour N:   { %f, %f, %f, %f )\n", pNeigDataN.x, pNeigDataN.y, pNeigDataN.z, pNeigDataN.w );
		printf( "Neighbour E:   { %f, %f, %f, %f )\n", pNeigDataE.x, pNeigDataE.y, pNeigDataE.z, pNeigDataE.w );
		printf( "Neighbour S:   { %f, %f, %f, %f )\n", pNeigDataS.x, pNeigDataS.y, pNeigDataS.z, pNeigDataS.w );
		printf( "Neighbour W:   { %f, %f, %f, %f )\n", pNeigDataW.x, pNeigDataW.y, pNeigDataW.z, pNeigDataW.w );
	}
	#endif

	if ( pCellData.x  - dCellBedElev  < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataN.x - dNeigBedElevN < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataE.x - dNeigBedElevE < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataS.x - dNeigBedElevS < VERY_SMALL ) ucDryCount++;
	if ( pNeigDataW.x - dNeigBedElevW < VERY_SMALL ) ucDryCount++;

	// All neighbours are dry? Don't bother calculating
	if ( ucDryCount >= 5 ) return;

	// Reconstruct interfaces
	// -> North
	ucStop += reconstructInterface(
		pCellData,							// Left cell data
		dCellBedElev,						// Left bed elevation
		pNeigDataN,							// Right cell data
		dNeigBedElevN,						// Right bed elevation
		&pLeft,								// Output for left
		&pRight,							// Output for right
		DOMAIN_DIR_N
	);
	pNeigDataN.x  = pRight.S0;
	dNeigBedElevN = pRight.S6;
	pFlux[DOMAIN_DIR_N] = riemannSolver( DOMAIN_DIR_N, pLeft, pRight, false );

	// -> South
	ucStop += reconstructInterface(
		pNeigDataS,							// Left cell data
		dNeigBedElevS,						// Left bed elevation
		pCellData,							// Right cell data
		dCellBedElev,						// Right bed elevation
		&pLeft,								// Output for left
		&pRight,							// Output for right
		DOMAIN_DIR_S
	);
	pNeigDataS.x  = pLeft.S0;
	dNeigBedElevS = pLeft.S6;
	pFlux[DOMAIN_DIR_S] = riemannSolver( DOMAIN_DIR_S, pLeft, pRight, false );

	// -> East
	ucStop += reconstructInterface(
		pCellData,							// Left cell data
		dCellBedElev,						// Left bed elevation
		pNeigDataE,							// Right cell data
		dNeigBedElevE,						// Right bed elevation
		&pLeft,								// Output for left
		&pRight,							// Output for right
		DOMAIN_DIR_E
	);
	pNeigDataE.x  = pRight.S0;
	dNeigBedElevE = pRight.S6;
	pFlux[DOMAIN_DIR_E] = riemannSolver( DOMAIN_DIR_E, pLeft, pRight, false );

	// -> West
	ucStop += reconstructInterface(
		pNeigDataW,							// Left cell data
		dNeigBedElevW,						// Left bed elevation
		pCellData,							// Right cell data
		dCellBedElev,						// Right bed elevation
		&pLeft,								// Output for left
		&pRight,							// Output for right
		DOMAIN_DIR_W
	);
	pNeigDataW.x  = pLeft.S0;
	dNeigBedElevW = pLeft.S6;
	pFlux[DOMAIN_DIR_W] = riemannSolver( DOMAIN_DIR_W, pLeft, pRight, false );

	// Source term vector
	// TODO: Somehow get these sorted too...
	pSourceTerms.x = 0.0;
	pSourceTerms.y = -1 * GRAVITY * ( ( pNeigDataE.x + pNeigDataW.x ) / 2 ) * ( ( dNeigBedElevE - dNeigBedElevW ) / DOMAIN_DELTAX );
	pSourceTerms.z = -1 * GRAVITY * ( ( pNeigDataN.x + pNeigDataS.x ) / 2 ) * ( ( dNeigBedElevN - dNeigBedElevS ) / DOMAIN_DELTAY );

	// Calculation of change values per timestep and spatial dimension
	dDeltaValues.x	= ( pFlux[1].x  - pFlux[3].x  )/DOMAIN_DELTAX + 
					  ( pFlux[0].x  - pFlux[2].x  )/DOMAIN_DELTAY - 
					  pSourceTerms.x;
	dDeltaValues.z	= ( pFlux[1].y - pFlux[3].y )/DOMAIN_DELTAX + 
					  ( pFlux[0].y - pFlux[2].y )/DOMAIN_DELTAY - 
					  pSourceTerms.y;
	dDeltaValues.w	= ( pFlux[1].z - pFlux[3].z )/DOMAIN_DELTAX + 
					  ( pFlux[0].z - pFlux[2].z )/DOMAIN_DELTAY - 
					  pSourceTerms.z;

	// Round delta values to zero if small
	// TODO: Explore whether this can be rewritten as some form of clamp operation?
	if ( ( dDeltaValues.x > 0.0 && dDeltaValues.x <  VERY_SMALL ) ||
		 ( dDeltaValues.x < 0.0 && dDeltaValues.x > -VERY_SMALL ) ) 
		 dDeltaValues.x = 0.0;
	if ( ( dDeltaValues.z > 0.0 && dDeltaValues.z <  VERY_SMALL ) ||
		 ( dDeltaValues.z < 0.0 && dDeltaValues.z > -VERY_SMALL ) ) 
		 dDeltaValues.z = 0.0;
	if ( ( dDeltaValues.w > 0.0 && dDeltaValues.w <  VERY_SMALL ) ||
		 ( dDeltaValues.w < 0.0 && dDeltaValues.w > -VERY_SMALL ) ) 
		 dDeltaValues.w = 0.0;

	// Stopping conditions
	if ( ucStop > 0 )
	{
		pCellData.z = 0.0;
		pCellData.w = 0.0;
	}

	// Update the flow state
	pCellData.x		= pCellData.x	- dLclTimestep * dDeltaValues.x;
	pCellData.z		= pCellData.z	- dLclTimestep * dDeltaValues.z;
	pCellData.w		= pCellData.w	- dLclTimestep * dDeltaValues.w;

	#ifdef FRICTION_ENABLED
	#ifdef FRICTION_IN_FLUX_KERNEL
	// Calculate the friction effects
	pCellData = implicitFriction(
		pCellData,
		dCellBedElev,
		dManningCoef,
		dLclTimestep
	);
	#endif
	#endif

	// New max FSL?
	if ( pCellData.x > pCellData.y && pCellData.y > -9990.0 )
		pCellData.y = pCellData.x;

	// Crazy low depths?
	if ( pCellData.x - dCellBedElev < VERY_SMALL )
		pCellData.x = dCellBedElev;

	#ifdef DEBUG_OUTPUT
	if ( lIdxX == DEBUG_CELLX && lIdxY == DEBUG_CELLY )
	{
		printf( "Timestep:      { %f )\n", dLclTimestep );
		printf( "Reconstruct N: { %f, %f, %f, %f )\n", pNeigDataN.x, dNeigBedElevN, pNeigDataN.z, pNeigDataN.w );
		printf( "Reconstruct E: { %f, %f, %f, %f )\n", pNeigDataE.x, dNeigBedElevE, pNeigDataE.z, pNeigDataE.w );
		printf( "Reconstruct S: { %f, %f, %f, %f )\n", pNeigDataS.x, dNeigBedElevS, pNeigDataS.z, pNeigDataS.w );
		printf( "Reconstruct W: { %f, %f, %f, %f )\n", pNeigDataW.x, dNeigBedElevW, pNeigDataW.z, pNeigDataW.w );
		printf( "Delta terms:   { %f, %f, %f )\n", dDeltaValues.x, dDeltaValues.z, dDeltaValues.w );
		printf( "Source terms:  { %f, %f, %f )\n", pSourceTerms.x, pSourceTerms.y, pSourceTerms.z );
		printf( "New data:      { %f, %f, %f, %f )\n", pCellData.x, pCellData.y, pCellData.z, pCellData.w );
	}
	#endif

	// Commit to global memory
	pCellStateDst[ ulIdx ] = pCellData;
}
/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  BOUNDARY CONDITIONS
 * ------------------------------------------
 *  Management functions for a domain
 *  boundaries.
 * ------------------------------------------
 *
 */

__kernel void bdy_Cell (
	__constant		sBdyCellConfiguration *		pConfiguration,
	__global		cl_ulong const * restrict	pRelations,
	__global		cl_double4 const * restrict pTimeseries,
	__global		cl_double *					pTime,
	__global		cl_double *					pTimestep,
	__global		cl_double *					pTimeHydrological,
	__global		cl_double4 *				pCellState,
	__global		cl_double *					pCellBed,
	__global		cl_double *					pCellManning
	)
{
	__private cl_long				lRelationID		= get_global_id(0);
	__private sBdyCellConfiguration pConfig			= *pConfiguration;
	__private cl_double				dLocalTime		= *pTime;
	__private cl_double				dLocalTimestep  = *pTimestep;

	if (lRelationID >= pConfig.RelationCount || dLocalTime >= pConfig.TimeseriesLength || dLocalTimestep <= 0.0)
		return;

	__private cl_ulong				ulBaseTimestep  = (cl_ulong)floor( dLocalTime / pConfig.TimeseriesInterval );
	__private cl_ulong				ulNextTimestep  = ulBaseTimestep + 1;
	__private cl_ulong				ulCellID		= pRelations[lRelationID];
	__private cl_double4			pCellData		= pCellState[ulCellID];
	__private cl_double				dCellBed		= pCellBed[ulCellID];
	__private cl_double4			pTSBase			= pTimeseries[ulBaseTimestep];
	__private cl_double4			pTSNext			= pTimeseries[ulNextTimestep];

	// Interpolate between timesteps
	__private cl_double4			pTSInterp = pTSBase + (pTSNext - pTSBase) * ( fmod(dLocalTime, pConfig.TimeseriesInterval ) / pConfig.TimeseriesInterval);

	// Apply depth/fsl
	if (pConfig.DefinitionDepth == BOUNDARY_DEPTH_IS_DEPTH)
	{
		#ifdef DEBUG_OUTPUT
		printf("Depth is fixed.\n");
		#endif
		pCellData.x = dCellBed + pTSInterp.y;			// Depth is fixed
	}
	else if (pConfig.DefinitionDepth == BOUNDARY_DEPTH_IS_FSL)
	{
		#ifdef DEBUG_OUTPUT
		printf("FSL is fixed.\n");
		#endif
		pCellData.x = fmax(dCellBed, pTSInterp.y);		// FSL is fixed
	}
	else
	{
		#ifdef DEBUG_OUTPUT
		printf("Depth and FSL are free.\n");
		#endif
		if (fabs(pTSInterp.z) > VERY_SMALL ||
			fabs(pTSInterp.w) > VERY_SMALL ||
			pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_VOLUME)
		{
			// Calculate a suitable depth based
			__private cl_double dDepth = (fabs(pTSInterp.z) * dLocalTimestep) / DOMAIN_DELTAY + (fabs(pTSInterp.w) * dLocalTimestep) / DOMAIN_DELTAX;
			__private cl_double dNormalDepth = fmax(pown(pTSInterp.z, 2) / GRAVITY, pown(pTSInterp.w, 2) / GRAVITY);
			__private cl_double dCriticalDepth = fmax(pow(pow(pTSInterp.z, 2) / GRAVITY, 1.0 / 3.0), pow(pow(pTSInterp.w, 2) / GRAVITY, 1.0 / 3.0));

			// Not going to impose a direction if we're trying to represent
			// a surging discharge rate (e.g. manhole surge)
			if (pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_VOLUME)
			{
				// In the case of volume boundaries, no scaling has taken place
				dNormalDepth = 0.0;
				dDepth = (fabs(pTSInterp.z) * dLocalTimestep) / (DOMAIN_DELTAX * DOMAIN_DELTAY);
				dCriticalDepth = 0.0;
				pTSInterp.z = 0.0;
				pTSInterp.w = 0.0;
			}
			
			pCellData.x = fmax(dCellBed + dCriticalDepth, pCellData.x + dDepth);
			
			#ifdef DEBUG_OUTPUT
			printf("Setting depth as %f.\n", dDepth);
			#endif
		}
	}

	if (pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_DISCHARGE)
	{
		// Apply flow in X direction
		pCellData.z = pTSInterp.z;
	}
	else if (pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_VELOCITY) {
		// Apply velocity in X direction
		pCellData.z = pTSInterp.z * (pCellData.x - dCellBed);
	}

	if (pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_DISCHARGE)
	{
		// Apply flow in Y direction
		pCellData.w = pTSInterp.w;
	}
	else if (pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_VELOCITY) {
		// Apply velocity in X direction
		pCellData.w = pTSInterp.w * (pCellData.x - dCellBed);
	}

	#ifdef DEBUG_OUTPUT
	printf("Final Cell Data:       { %f, %f, %f, %f }\n", pCellData.x, pCellData.y, pCellData.z, pCellData.w);
	#endif

	pCellState[ ulCellID ] = pCellData;
}
















__kernel void bdy_Uniform(
	__constant		sBdyUniformConfiguration *	pConfiguration,
	__global		cl_double2 const * restrict	pTimeseries,
	__global		cl_double *					pTime,
	__global		cl_double *					pTimestep,
	__global		cl_double *					pTimeHydrological,
	__global		cl_double4 *				pCellState,
	__global		cl_double *					pCellBed,
	__global		cl_double *					pCellManning
	)
{
	// Which global series are we processing, and which cell
	// Global ID is X, Y cell, then Z for the series
	__private cl_long		lIdxX = get_global_id(0);
	__private cl_long		lIdxY = get_global_id(1);
	__private cl_ulong		ulIdx;

	// Don't bother if we've gone beyond the domain bounds
	if (lIdxX >= DOMAIN_COLS - 1 ||
		lIdxY >= DOMAIN_ROWS - 1 ||
		lIdxX <= 0 ||
		lIdxY <= 0){
		return;}

	ulIdx = getCellID(lIdxX, lIdxY);

	// How far in to the simulation are we? And current cell data
	__private sBdyUniformConfiguration	pConfig			= *pConfiguration;
	__private cl_double4				pCellData		= pCellState[ulIdx];
	__private cl_double					dCellBedElev	= pCellBed[ulIdx];
	__private cl_double					dLclTime		= *pTime;
	__private cl_double					dLclRealTimestep= *pTimestep;
	__private cl_double					dLclTimestep	= *pTimeHydrological;

	// Hydrological processes have their own timesteps
	if (dLclTimestep < TIMESTEP_HYDROLOGICAL || dLclRealTimestep <= 0.0)
		return;

	if ( dLclTime >= pConfig.TimeseriesLength || pCellData.y <= -9999.0 )
		return;

	// Calculate the right cell and stuff to be grabbing data from here...
	__private cl_ulong ulTimestep = (cl_ulong)floor(dLclTime / pConfig.TimeseriesInterval);
	__private cl_double2 dRecord = pTimeseries[ulTimestep];

	//printf("%i %lf %lf %i\n",
	//pConfig.TimeseriesEntries,
	//pConfig.TimeseriesInterval,
	//pConfig.TimeseriesLength,
	//pConfig.Definition
	//);


	
	//cl_uint			TimeseriesEntries;
	//cl_double		TimeseriesInterval;
	//cl_double		TimeseriesLength;
	//cl_uint			Definition;





	// Apply the value...
	if (pConfig.Definition == BOUNDARY_UNIFORM_RAIN_INTENSITY)
		pCellData.x += dRecord.y / 3600000.0 * dLclTimestep;
		//printf("\ndRecord.y: %lf", dRecord.y);

	if (pConfig.Definition == BOUNDARY_UNIFORM_LOSS_RATE)
		pCellData.x = max(dCellBedElev, pCellData.x - dRecord.y / 3600000.0 * dLclTimestep);

	// Return to global memory
	pCellState[ulIdx] = pCellData;
}



















__kernel void bdy_Gridded (
	__constant		sBdyGriddedConfiguration *	pConfiguration,
	__global		cl_double const * restrict	pTimeseries,
	__global		cl_double *					pTime,
	__global		cl_double *					pTimestep,
	__global		cl_double *					pTimeHydrological,
	__global		cl_double4 *				pCellState,
	__global		cl_double *					pCellBed,
	__global		cl_double *					pCellManning
	)
{
	// Which global series are we processing, and which cell
	// Global ID is X, Y cell, then Z for the series
	__private cl_long		lIdxX = get_global_id(0);
	__private cl_long		lIdxY = get_global_id(1);
	__private cl_ulong		ulIdx;

	// Don't bother if we've gone beyond the domain bounds
	if (lIdxX >= DOMAIN_COLS - 1 ||
		lIdxY >= DOMAIN_ROWS - 1 ||
		lIdxX <= 0 ||
		lIdxY <= 0 )
		return;

	ulIdx = getCellID(lIdxX, lIdxY);

	// How far in to the simulation are we? And current cell data
	__private sBdyGriddedConfiguration	pConfig			= *pConfiguration;
	__private cl_double4				pCellData		= pCellState[ulIdx];
	__private cl_double					dCellBedElev	= pCellBed[ulIdx];
	__private cl_double					dLclTime		= *pTime;
	__private cl_double					dLclTimestep	= *pTimeHydrological;

	// Cell disabled?
	if (pCellData.y <= -9999.0 || pCellData.x == -9999.0)
		return;

	// Hydrological processes have their own timesteps
	if (dLclTimestep < TIMESTEP_HYDROLOGICAL)
		return;

	// Calculate the right cell and stuff to be grabbing data from here...
	__private cl_ulong ulTimestep = (cl_ulong)floor( dLclTime / pConfig.TimeseriesInterval );
	if ( ulTimestep >= pConfig.TimeseriesEntries ) ulTimestep = pConfig.TimeseriesEntries;

	__private cl_double ulColumn  = floor( ( ( (cl_double)lIdxX * (cl_double)DOMAIN_DELTAX ) - pConfig.GridOffsetX ) / pConfig.GridResolution );
	__private cl_double ulRow     = floor( ( ( (cl_double)lIdxY * (cl_double)DOMAIN_DELTAY ) - pConfig.GridOffsetY ) / pConfig.GridResolution );
	__private cl_ulong ulBdyCell  = ( pConfig.GridRows * pConfig.GridCols ) * ulTimestep +
									( pConfig.GridCols * (cl_ulong)ulRow ) + (cl_ulong)ulColumn;
	__private cl_double dRate	  = pTimeseries[ ulBdyCell ];

	// Apply the value...
	if ( pConfig.Definition == BOUNDARY_GRIDDED_RAIN_INTENSITY )
		pCellData.x += dRate / 3600000.0 * dLclTimestep;

	if ( pConfig.Definition == BOUNDARY_GRIDDED_MASS_FLUX )
		pCellData.x += dRate / ( (cl_double)DOMAIN_DELTAX * (cl_double)DOMAIN_DELTAY ) * dLclTimestep;

	// Return to global memory
	pCellState[ulIdx] = pCellData;
}
